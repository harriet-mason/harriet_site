---
title: "Swap from interp::tri.mesh() to tRiad::Deltri()"
editor: source
knitr:
  opts_chunk: 
    warning: FALSE
    message: FALSE
---

## Motivation for Swap

While most scatter plots that had a delauney triangulation in tripack also have one with interp, there are a handful of scatter plots that do not. These scatter plots take a HUGE amount of time to find the delauney triangulation for no clear reason. Any clear visual feature of the scatter plot can be replicated in another but it does not take as long. This problem is not a feature of the delauney triangulation itself. The tri.mesh function is computed almost instantaneously with tripack, but takes significantly longer with interp. An example of a scatter plot that takes a very long time is below. I compared the time it takes for each package to compute the triangulation, including tRiad, the suggested replacement for interp.

```{r}
library(fitzRoy)
library(dplyr)
library(interp)
library(cassowaryr)
library(tidyverse)
# triad is not on CRAN
# devtools::install_github("ZeroDawn0D/tRiad")
library(tRiad)

# Get data and find scatter plot that is instant and long scatter plot
aflw <- fetch_player_stats(2020, comp = "AFLW")
```

```{r}
aflw_num <- aflw %>%
  select_if(is.numeric)

aflw_num <- aggregate(aflw_num[,5:37],
                      list(aflw$player.player.player.surname),
                      mean)

# problem scatter plots
a <- aflw_num$goals
c <- aflw_num$handballs

# plot it
plot(a,c)

#Follow code down to tri.mesh 
# to make sure I have the same input
ac <- cbind(cassowaryr:::unitize(a), cassowaryr:::unitize(c))
dupes <- paste(a, c, sep =",")
ac <- ac[!duplicated(dupes),]
x <- ac
y = NULL
X <- xy.coords(x, y)

system.time(interp::tri.mesh(X))
system.time(tripack::tri.mesh(X))
system.time(tRiad::del.tri(X))
system.time(tRiad::DelTri(a,c))
```

For most scatter plots interp performs a faster delauney triangulation than the C++ DelTri function in tRiad. This is only really noticiable when working with scatter plots that have a large number of points.

```{r}
# small scatter plot
x <- runif(500)
y <- runif(500)
plot(x,y)
system.time(tRiad::DelTri(x,y))
system.time(interp::tri.mesh(x,y))

# big scatter plot
x <- runif(5000)
y <- runif(5000)
plot(x,y)
system.time(tRiad::DelTri(x,y))
system.time(interp::tri.mesh(x,y))
```

For most plots interp is faster than tRiad, resulting in a lower time on average, however the issue of the occasional *very long* computation time on an interp plot results in a much higher variance. This issue occurs occasionally in simulated continuous data.

```{r, eval=FALSE}
# set seed
set.seed(1)
# set n
n <- 1000
  
# time vector
triadtime <- rep(0, n)
interptime <- rep(0, n)
  
  # run a bunch of times
for(i in seq(n)){
  x <- runif(500)
  y <- runif(500)
  triadtime[i] <- system.time(tRiad::DelTri(x,y))[[3]]
  interptime[i] <- system.time(interp::tri.mesh(x,y))[[3]]
}

# compare visually
timetable <- tibble(
  triad = triadtime,
  interp = interptime
) 
saveRDS(timetable, file = "timetable1.rds")
```

```{r}
timetable <- readRDS(file = "timetable1.rds")

timetable %>%
  pivot_longer(everything(), names_to="package", values_to="time") %>%
  ggplot(aes(x=package, y=time, colour=package)) +
  geom_jitter(width=0.5, height=0)

```

What is of greater concern is that this problem occurs much more frequently in real, non-simulated, data sets.

```{r, eval=FALSE}
# interp throws an error without preprocessing, so I'm making an in between function
prep_interp <- function(x,y){
  xy <- cbind(cassowaryr:::unitize(x), cassowaryr:::unitize(y))
  dupes <- paste(x, y, sep =",")
  xy <- xy[!duplicated(dupes),]
  x <- xy
  y = NULL
  X <- xy.coords(x, y)
  system.time(interp::tri.mesh(X))
}

prep_triad <- function(x,y){
  xy <- cbind(cassowaryr:::unitize(x), cassowaryr:::unitize(y))
  dupes <- paste(x, y, sep =",")
  xy <- xy[!duplicated(dupes),]
  system.time(tRiad::DelTri(xy[,1],xy[,2]))
}

# calculate time on collection of scatter plots
aflw_test <- aflw_num[,2:9]

combinations <- expand.grid(colnames(aflw_test), colnames(aflw_test)) %>%
    dplyr::filter(!(Var1==Var2))

# Write as a for loop because tidy version was a nightmare to debug
n <- length(combinations$Var1)
triadtime <- rep(0, n)
interptime <- rep(0, n)

for(i in seq(n)){
  x <- dplyr::pull(aflw_test,var=combinations$Var1[i])
  y <- dplyr::pull(aflw_test, var=combinations$Var2[i])
  triadtime[i] <- prep_triad(x, y)[[3]]
  interptime[i] <- prep_interp(x, y)[[3]]
}

# put into a tibble and plot
timetable <- tibble(
  triad = triadtime,
  interp = interptime
) 

saveRDS(timetable, file = "timetable2.rds")
```

```{r}
timetable <- readRDS(file = "timetable2.rds")

timetable %>%
  pivot_longer(everything(), names_to="package", values_to="time") %>%
  ggplot(aes(x=package, y=time, colour=package)) +
  geom_jitter(width=0.3, height=0)
```

Additionally the interp package occasionally throws an error on scatter plots that are visually indistinguishable from plots that do not throw an error. These scatter plots work fine

```{r}
# Plot that throws an error
d <- aflw_num$totalPossessions
e <- aflw_num$contestedPossessions
plot(d,e)

#Follow code down to tri.mesh 
# to make sure I have the same input
de <- cbind(cassowaryr:::unitize(d), cassowaryr:::unitize(e))
dupes <- paste(d, e, sep =",")
de <- de[!duplicated(dupes),]
x <- de
y = NULL
X <- xy.coords(x, y)

# compare methods
system.time(tripack::tri.mesh(X))
system.time(tRiad::DelTri(d,e))
```

```{r, error=TRUE}
system.time(interp::tri.mesh(X))
```

While the faster tRiad triangulation is written in C++, it also has a version of its functions written in R. This makes it easier for the R community to contribute and debug the code. From my understanding of interp, the actual delauney triangulation is computed using the shull.deltri function from the C shull library. So tRiad has additional transparency that interp does not.

Due to the issues with interp caused by computation time, errors, and transparency, I think it would be beneficial to swap the alphahull package to tRiad.

## Replacement Functions
Both cassowaryr and alphahull use interp fucntions that are not `tri.mesh()`, so a complete replacement of interp is not feasible.

### In cassowaryr
cassowaryr directly calls interp once, in R/alphahull.R line 95 `interp::convex.hull(del$tri.obj)`. We do not have a replacement function for this.

### In alphahull
The alphahull code does not directly call the interp package with "interp::" so I can't find the uses, but the namespace has `importFrom("interp", "circum", "in.convex.hull", "tri.mesh", "triangles")`. We only have a replacement for `tri.mesh()`.

## Triad Changes
### Needed for Swap
The missing functions is the biggest issue for the swap, however I don't think we need to replace them. The other interp functions don't seem to create any error (as far as I can tell). We COULD add functions into tRiad that replace the other interp functions, but I am not sure the author of alphahull (who also wrote interp) would be super keen on that since there isn't anything wrong with that part of the package. Therefore I think it would be better to pitch tRiad as a replacement for the C++ library, shull (which it kind of is). Then we don't want alphahull to swap from interp to tRiad, but we want interp to swap from shull to tRiad. The issue with this is that the function was written at the alphahull level, so really we are just asking alphahull to replace one function.

I am not sure if tRiad can just replace interp. The interp triangles function needs to work with the tRiad output, which it currently does not.

```{r, eval=FALSE}
# Code taken straight from alphahull package
delvor <-
function (x, y = NULL) 
{
    X <- xy.coords(x, y)
    x <- cbind(X$x, X$y)
    if (dim(x)[1] <= 2) {
        stop("At least three non-collinear points are required")
    }
    #tri.obj <- tri.mesh(X)
    tri.obj <- tRiad::DelTri(X$x, X$y)
    tri <- triangles(tri.obj) # <<<<<<<--------- this line is where the issue is
    nt <- nrow(tri)
    circenter <- matrix(nrow = nt, ncol = 2) 
    colnames(circenter) <- c("circumx", "circumy")
    for (i in 1:nt){
		aux <- circum(c(x[tri[i, 1], 1], x[tri[i, 2], 1], x[tri[i, 3], 1]), c(x[tri[i, 1], 2], x[tri[i, 2], 2], x[tri[i, 3], 2]))
		circenter[i, ] <- c(aux$x, aux$y)
    }
    tri.info<-cbind(tri, circenter)

    n.tri <- dim(tri.info)[1]
    n.arc <- max(tri.info[, 7:9])
    if (n.tri == 1) {
        aux1 <- cbind(matrix(tri.info[, c("arc1", "node2", "node3")], 
            ncol = 3, nrow = 1), 1:n.tri, tri.info[, "tr1"])
        aux2 <- cbind(matrix(tri.info[, c("arc2", "node1", "node3")], 
            ncol = 3, nrow = 1), 1:n.tri, tri.info[, "tr2"])
        aux3 <- cbind(matrix(tri.info[, c("arc3", "node1", "node2")], 
            ncol = 3, nrow = 1), 1:n.tri, tri.info[, "tr3"])
    }
    else {
        aux1 <- cbind(tri.info[, c("arc1", "node2", "node3")], 
            1:n.tri, tri.info[, "tr1"])
        aux2 <- cbind(tri.info[, c("arc2", "node1", "node3")], 
            1:n.tri, tri.info[, "tr2"])
        aux3 <- cbind(tri.info[, c("arc3", "node1", "node2")], 
            1:n.tri, tri.info[, "tr3"])
    }
    aux <- rbind(aux1, aux2, aux3)
    repeated <- duplicated(aux[, 1])
    aux <- aux[!repeated, ]
    colnames(aux) <- c("arc", "ind1", "ind2", "indm1", "indm2")
    bp1 <- (aux[, "indm1"] == 0)
    bp2 <- (aux[, "indm2"] == 0)
    is.dummy <- which(bp2)
    n.dummy <- length(is.dummy)
    circumcentres <- tri.info[, c("circumx", "circumy")]
    away <- max(diff(range(x[, 1])), diff(range(x[, 2])))
    for (i in is.dummy) {
        n.tri <- n.tri + 1
        dum <- dummycoor(tri.obj, x[aux[i, "ind1"], ], x[aux[i, 
            "ind2"], ], tri.info[aux[i, "indm1"], c("circumx", 
            "circumy")], away)
        circumcentres <- rbind(circumcentres, dum)
        aux[i, "indm2"] <- n.tri
    }
    mesh <- cbind(aux[, c("ind1", "ind2")], x[aux[, "ind1"], 
        ], x[aux[, "ind2"], ], circumcentres[aux[, "indm1"], 
        ], circumcentres[aux[, "indm2"], ], bp1, bp2)
    colnames(mesh) <- c("ind1", "ind2", "x1", "y1", "x2", "y2", 
        "mx1", "my1", "mx2", "my2", "bp1", "bp2")
    delvor.obj <- list(mesh = mesh, x = x, tri.obj = tri.obj)
    class(delvor.obj) <- "delvor"
    invisible(delvor.obj)
}
del <- delvor(ac)
```

### Reccomended for Swap
- `tRiad::Deltri()` seems to take an infinitely long time if there are duplicate points. I didn't check `tRiad::del.tri()`. I haven't made 100% sure that it is duplicate points, but `interp::tri.mesh()` and `tripack::tri.mesh()` gave an error about duplicate points on the same scatter plot. 
- It might be beneficial to allow `tRiad::Deltri()` to take a list as input because that is how alphahull calls `interp::tri.mesh()`. Every other version of the function including `tRiad::del.tri()` allow a list as input, so I am not sure why `tRiad::Deltri()` doesn't.
- GSOC article doesn't work if you try and run the code because it has "triad" instead of "tRiad" since it was written before the name change. 
- The readme does not run because it loads the library with `library("triad")` which also (I think?) doesn't work.
- There are a lot of functions in the tRiad reference. Do all the functions need to be exported? A lot of them look like behind the scenes calculations and having them all listed makes it a little difficult to tell which functions should be common use for the user.