---
title: "Swap from Interp to Triad"
editor: visual
---

## Motivation for Swap

While most scatter plots that had a delauney triangulation in tripack also have one with interp, there are a handful of scatter plots that do not. These scatter plots take a HUGE amount of time to find the delauney triangulation for no clear reason. Any clear visual feature of the scatter plot can be replicated in another but it does not take as long. This problem is not a feature of the delauney triangulation itself. The tri.mesh function is computed almost instantaneously with tripack, but takes significantly longer with interp. An example of a scatter plot that takes a very long time is below. I compared the time it takes for each package to compute the triangulation, including tRiad, the suggested replacement for interp.

```{r}
library(fitzRoy)
library(dplyr)
library(interp)
library(cassowaryr)
library(tidyverse)
# triad is not on CRAN
# devtools::install_github("ZeroDawn0D/tRiad")
library(tRiad)

# Get data and find scatter plot that is instant and long scatter plot
aflw <- fetch_player_stats(2020, comp = "AFLW")

aflw_num <- aflw %>%
  select_if(is.numeric)

aflw_num <- aggregate(aflw_num[,5:37],
                      list(aflw$player.player.player.surname),
                      mean)

# problem scatter plots
a <- aflw_num$goals
c <- aflw_num$handballs

# plot it
plot(a,c)

#Follow code down to tri.mesh 
# to make sure I have the same input
ac <- cbind(cassowaryr:::unitize(a), cassowaryr:::unitize(c))
dupes <- paste(a, c, sep =",")
ac <- ac[!duplicated(dupes),]
x <- ac
y = NULL
X <- xy.coords(x, y)

system.time(interp::tri.mesh(X))
system.time(tripack::tri.mesh(X))
system.time(tRiad::del.tri(X))
system.time(tRiad::DelTri(a,c))
```

For most scatter plots interp performs a faster delauney triangulation than the C++ DelTri function in tRiad. This is only really noticiable when working with scatter plots that have a large number of points.

```{r}
# small scatter plot
x <- runif(500)
y <- runif(500)
plot(x,y)
system.time(tRiad::DelTri(x,y))
system.time(interp::tri.mesh(x,y))

# big scatter plot
x <- runif(5000)
y <- runif(5000)
plot(x,y)
system.time(tRiad::DelTri(x,y))
system.time(interp::tri.mesh(x,y))
```

For most plots interp is faster than tRiad, resulting in a lower time on average, however the issue of the occasional *very long* computation time on an interp plot results in a much higher variance. This issue occurs occasionally in simulated continuous data.

```{r}
# set seed
set.seed(1)
# set n
n <- 1000
  
# time vector
triadtime <- rep(0, n)
interptime <- rep(0, n)
  
  # run a bunch of times
for(i in seq(n)){
  x <- runif(500)
  y <- runif(500)
  triadtime[i] <- system.time(tRiad::DelTri(x,y))[[3]]
  interptime[i] <- system.time(before_interp(x,y))[[3]]
}

# compare visually
timetable <- tibble(
  triad = triadtime,
  interp = interptime
) 

timetable %>%
  pivot_longer(everything(), names_to="package", values_to="time") %>%
  ggplot(aes(x=package, y=time, colour=package)) +
  geom_jitter(width=0.5, height=0)

```

What is of greater concern is that this problem occurs much more frequently in real, non-simulated, data sets.

```{r}
# interp throws an error without preprocessing, so I'm making an in between function
prep_interp <- function(x,y){
  xy <- cbind(cassowaryr:::unitize(x), cassowaryr:::unitize(y))
  dupes <- paste(x, y, sep =",")
  xy <- xy[!duplicated(dupes),]
  x <- xy
  y = NULL
  X <- xy.coords(x, y)
  system.time(interp::tri.mesh(X))
}

prep_triad <- function(x,y){
  xy <- cbind(cassowaryr:::unitize(x), cassowaryr:::unitize(y))
  dupes <- paste(x, y, sep =",")
  xy <- xy[!duplicated(dupes),]
  system.time(tRiad::DelTri(xy[,1],xy[,2]))
}

# calculate time on collection of scatter plots
aflw_test <- aflw_num[,2:9]

combinations <- expand.grid(colnames(aflw_test), colnames(aflw_test)) %>%
    dplyr::filter(!(Var1==Var2))

# Write as a for loop because tidy version was a nightmare to debug
n <- length(combinations$Var1)
triadtime <- rep(0, n)
interptime <- rep(0, n)

for(i in seq(n)){
  x <- dplyr::pull(aflw_test,var=combinations$Var1[i])
  y <- dplyr::pull(aflw_test, var=combinations$Var2[i])
  triadtime[i] <- prep_triad(x, y)[[3]]
  interptime[i] <- prep_interp(x, y)[[3]]
}

# put into a tibble and plot
timetable <- tibble(
  triad = triadtime,
  interp = interptime
) 

timetable %>%
  pivot_longer(everything(), names_to="package", values_to="time") %>%
  ggplot(aes(x=package, y=time, colour=package)) +
  geom_jitter(width=0.3, height=0)

combinations[which(interptime>50),]
```

Additionally the interp package occasionally throws an error on scatter plots that are visually indistinguishable from plots that do not throw an error. These scatter plots work fine 

```{r}
# Plot that throws an error
d <- aflw_num$totalPossessions
e <- aflw_num$contestedPossessions
plot(d,e)

#Follow code down to tri.mesh 
# to make sure I have the same input
de <- cbind(cassowaryr:::unitize(d), cassowaryr:::unitize(e))
dupes <- paste(d, e, sep =",")
de <- de[!duplicated(dupes),]
x <- de
y = NULL
X <- xy.coords(x, y)

# compare methods
system.time(tripack::tri.mesh(X))
system.time(tRiad::DelTri(d,e))
```

```{r, eval=FALSE}
system.time(interp::tri.mesh(X))
```
While the faster tRiad triangulation is written in C++, it also has a version of its functions written in R. This makes it easier for the R community to contribute and debug the code. From my understanding of interp, the actual delauney triangulation is computed using the `shull.deltri` function from the C shull library. So tRiad has additional transparency that interp does not.

Due to the issues with interp caused by computation time, errors, and transparency, I think it would be beneficial to swap the alphahull package to tRiad.

## Changes

### In cassowaryr

### In alphahull

## Do things work?

## Triad issues

-   GSOC article doesn't work if you try and run the code because it has triad instead of tRiad
-   Readme has library("triad") and I'm not sure if the quotations hurt anything
-   It might be beneficial to allow the tRiad functions to be called in the same way alphahull calls interp. It works for the R version of the function, i.e. tRiad::del.tri(X) runs, but the C++ version of the function does not.
- Deltri seems to take an infinitely long time if there are duplicate points? Looking at case of aflw behinds vs goals plot. The other methods give an error, I'm not sure what is happening in it since I can't read C++. I'm not sure about the the triad R version.