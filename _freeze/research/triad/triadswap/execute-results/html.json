{
  "hash": "35e5239bb7b0861f12a0182d09ac374e",
  "result": {
    "markdown": "---\ntitle: \"Swap from interp::tri.mesh() to tRiad::Deltri()\"\neditor: source\nknitr:\n  opts_chunk: \n    warning: FALSE\n    message: FALSE\n---\n\n\n## Motivation for Swap\n\nWhile most scatter plots that had a delauney triangulation in tripack also have one with interp, there are a handful of scatter plots that do not. These scatter plots take a HUGE amount of time to find the delauney triangulation for no clear reason. Any clear visual feature of the scatter plot can be replicated in another but it does not take as long. This problem is not a feature of the delauney triangulation itself. The tri.mesh function is computed almost instantaneously with tripack, but takes significantly longer with interp. An example of a scatter plot that takes a very long time is below. I compared the time it takes for each package to compute the triangulation, including tRiad, the suggested replacement for interp.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(fitzRoy)\nlibrary(dplyr)\nlibrary(interp)\nlibrary(cassowaryr)\nlibrary(tidyverse)\n# triad is not on CRAN\n# devtools::install_github(\"ZeroDawn0D/tRiad\")\nlibrary(tRiad)\n\n# Get data and find scatter plot that is instant and long scatter plot\naflw <- fetch_player_stats(2020, comp = \"AFLW\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\naflw_num <- aflw %>%\n  select_if(is.numeric)\n\naflw_num <- aggregate(aflw_num[,5:37],\n                      list(aflw$player.player.player.surname),\n                      mean)\n\n# problem scatter plots\na <- aflw_num$goals\nc <- aflw_num$handballs\n\n# plot it\nplot(a,c)\n```\n\n::: {.cell-output-display}\n![](triadswap_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n\n```{.r .cell-code}\n#Follow code down to tri.mesh \n# to make sure I have the same input\nac <- cbind(cassowaryr:::unitize(a), cassowaryr:::unitize(c))\ndupes <- paste(a, c, sep =\",\")\nac <- ac[!duplicated(dupes),]\nx <- ac\ny = NULL\nX <- xy.coords(x, y)\n\nsystem.time(interp::tri.mesh(X))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n 63.427   8.149  76.027 \n```\n:::\n\n```{.r .cell-code}\nsystem.time(tripack::tri.mesh(X))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.003   0.001   0.006 \n```\n:::\n\n```{.r .cell-code}\nsystem.time(tRiad::del.tri(X))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.030   0.002   0.033 \n```\n:::\n\n```{.r .cell-code}\nsystem.time(tRiad::DelTri(a,c))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.001   0.000   0.001 \n```\n:::\n:::\n\n\nFor most scatter plots interp performs a faster delauney triangulation than the C++ DelTri function in tRiad. This is only really noticiable when working with scatter plots that have a large number of points.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# small scatter plot\nx <- runif(500)\ny <- runif(500)\nplot(x,y)\n```\n\n::: {.cell-output-display}\n![](triadswap_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n\n```{.r .cell-code}\nsystem.time(tRiad::DelTri(x,y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.003   0.000   0.003 \n```\n:::\n\n```{.r .cell-code}\nsystem.time(interp::tri.mesh(x,y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.002   0.000   0.002 \n```\n:::\n\n```{.r .cell-code}\n# big scatter plot\nx <- runif(5000)\ny <- runif(5000)\nplot(x,y)\n```\n\n::: {.cell-output-display}\n![](triadswap_files/figure-html/unnamed-chunk-3-2.png){width=672}\n:::\n\n```{.r .cell-code}\nsystem.time(tRiad::DelTri(x,y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.113   0.000   0.113 \n```\n:::\n\n```{.r .cell-code}\nsystem.time(interp::tri.mesh(x,y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.082   0.000   0.082 \n```\n:::\n:::\n\n\nFor most plots interp is faster than tRiad, resulting in a lower time on average, however the issue of the occasional *very long* computation time on an interp plot results in a much higher variance. This issue occurs occasionally in simulated continuous data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# set seed\nset.seed(1)\n# set n\nn <- 1000\n  \n# time vector\ntriadtime <- rep(0, n)\ninterptime <- rep(0, n)\n  \n  # run a bunch of times\nfor(i in seq(n)){\n  x <- runif(500)\n  y <- runif(500)\n  triadtime[i] <- system.time(tRiad::DelTri(x,y))[[3]]\n  interptime[i] <- system.time(interp::tri.mesh(x,y))[[3]]\n}\n\n# compare visually\ntimetable <- tibble(\n  triad = triadtime,\n  interp = interptime\n) \nsaveRDS(timetable, file = \"timetable1.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntimetable <- readRDS(file = \"timetable1.rds\")\n\ntimetable %>%\n  pivot_longer(everything(), names_to=\"package\", values_to=\"time\") %>%\n  ggplot(aes(x=package, y=time, colour=package)) +\n  geom_jitter(width=0.5, height=0)\n```\n\n::: {.cell-output-display}\n![](triadswap_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nWhat is of greater concern is that this problem occurs much more frequently in real, non-simulated, data sets.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# interp throws an error without preprocessing, so I'm making an in between function\nprep_interp <- function(x,y){\n  xy <- cbind(cassowaryr:::unitize(x), cassowaryr:::unitize(y))\n  dupes <- paste(x, y, sep =\",\")\n  xy <- xy[!duplicated(dupes),]\n  x <- xy\n  y = NULL\n  X <- xy.coords(x, y)\n  system.time(interp::tri.mesh(X))\n}\n\nprep_triad <- function(x,y){\n  xy <- cbind(cassowaryr:::unitize(x), cassowaryr:::unitize(y))\n  dupes <- paste(x, y, sep =\",\")\n  xy <- xy[!duplicated(dupes),]\n  system.time(tRiad::DelTri(xy[,1],xy[,2]))\n}\n\n# calculate time on collection of scatter plots\naflw_test <- aflw_num[,2:9]\n\ncombinations <- expand.grid(colnames(aflw_test), colnames(aflw_test)) %>%\n    dplyr::filter(!(Var1==Var2))\n\n# Write as a for loop because tidy version was a nightmare to debug\nn <- length(combinations$Var1)\ntriadtime <- rep(0, n)\ninterptime <- rep(0, n)\n\nfor(i in seq(n)){\n  x <- dplyr::pull(aflw_test,var=combinations$Var1[i])\n  y <- dplyr::pull(aflw_test, var=combinations$Var2[i])\n  triadtime[i] <- prep_triad(x, y)[[3]]\n  interptime[i] <- prep_interp(x, y)[[3]]\n}\n\n# put into a tibble and plot\ntimetable <- tibble(\n  triad = triadtime,\n  interp = interptime\n) \n\nsaveRDS(timetable, file = \"timetable2.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntimetable <- readRDS(file = \"timetable2.rds\")\n\ntimetable %>%\n  pivot_longer(everything(), names_to=\"package\", values_to=\"time\") %>%\n  ggplot(aes(x=package, y=time, colour=package)) +\n  geom_jitter(width=0.3, height=0)\n```\n\n::: {.cell-output-display}\n![](triadswap_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nAdditionally the interp package occasionally throws an error on scatter plots that are visually indistinguishable from plots that do not throw an error. These scatter plots work fine\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot that throws an error\nd <- aflw_num$totalPossessions\ne <- aflw_num$contestedPossessions\nplot(d,e)\n```\n\n::: {.cell-output-display}\n![](triadswap_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n\n```{.r .cell-code}\n#Follow code down to tri.mesh \n# to make sure I have the same input\nde <- cbind(cassowaryr:::unitize(d), cassowaryr:::unitize(e))\ndupes <- paste(d, e, sep =\",\")\nde <- de[!duplicated(dupes),]\nx <- de\ny = NULL\nX <- xy.coords(x, y)\n\n# compare methods\nsystem.time(tripack::tri.mesh(X))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.000   0.000   0.001 \n```\n:::\n\n```{.r .cell-code}\nsystem.time(tRiad::DelTri(d,e))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.002   0.000   0.002 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsystem.time(interp::tri.mesh(X))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in shull.deltri(x1, y1): error counting arcs!\n```\n:::\n:::\n\n\nWhile the faster tRiad triangulation is written in C++, it also has a version of its functions written in R. This makes it easier for the R community to contribute and debug the code. From my understanding of interp, the actual delauney triangulation is computed using the shull.deltri function from the C shull library. So tRiad has additional transparency that interp does not.\n\nDue to the issues with interp caused by computation time, errors, and transparency, I think it would be beneficial to swap the alphahull package to tRiad.\n\n## Replacement Functions\nBoth cassowaryr and alphahull use interp fucntions that are not `tri.mesh()`, so a complete replacement of interp is not feasible.\n\n### In cassowaryr\ncassowaryr directly calls interp once, in R/alphahull.R line 95 `interp::convex.hull(del$tri.obj)`. We do not have a replacement function for this.\n\n### In alphahull\nThe alphahull code does not directly call the interp package with \"interp::\" so I can't find the uses, but the namespace has `importFrom(\"interp\", \"circum\", \"in.convex.hull\", \"tri.mesh\", \"triangles\")`. We only have a replacement for `tri.mesh()`.\n\n## Triad Changes\n### Needed for Swap\nThe missing functions is the biggest issue for the swap, however I don't think we need to replace them. The other interp functions don't seem to create any error (as far as I can tell). We COULD add functions into tRiad that replace the other interp functions, but I am not sure the author of alphahull (who also wrote interp) would be super keen on that since there isn't anything wrong with that part of the package. Therefore I think it would be better to pitch tRiad as a replacement for the C++ library, shull (which it kind of is). Then we don't want alphahull to swap from interp to tRiad, but we want interp to swap from shull to tRiad. The issue with this is that the function was written at the alphahull level, so really we are just asking alphahull to replace one function.\n\n### Reccomended for Swap\n- `tRiad::Deltri()` seems to take an infinitely long time if there are duplicate points. I didn't check `tRiad::del.tri()`. I haven't made 100% sure that it is duplicate points, but `interp::tri.mesh()` and `tripack::tri.mesh()` gave an error about duplicate points on the same scatter plot. \n- It might be beneficial to allow `tRiad::Deltri()` to take a list as input because that is how alphahull calls `interp::tri.mesh()`. Every other version of the function including `tRiad::del.tri()` allow a list as input, so I am not sure why `tRiad::Deltri()` doesn't.\n- GSOC article doesn't work if you try and run the code because it has \"triad\" instead of \"tRiad\" since it was written before the name change. \n- The readme does not run because it loads the library with `library(\"triad\")` which also (I think?) doesn't work.\n- There are a lot of functions in the tRiad reference. Do all the functions need to be exported? A lot of them look like behind the scenes calculations and having them all listed makes it a little difficult to tell which functions should be common use for the user.",
    "supporting": [
      "triadswap_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}