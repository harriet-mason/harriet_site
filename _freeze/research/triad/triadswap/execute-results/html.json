{
  "hash": "6a128fadef56d3476b110a3edebd3eee",
  "result": {
    "markdown": "---\ntitle: \"Swap from Interp to Triad\"\neditor: source\n---\n\n\n## Motivation for Swap\n\nWhile most scatter plots that had a delauney triangulation in tripack also have one with interp, there are a handful of scatter plots that do not. These scatter plots take a HUGE amount of time to find the delauney triangulation for no clear reason. Any clear visual feature of the scatter plot can be replicated in another but it does not take as long. This problem is not a feature of the delauney triangulation itself. The tri.mesh function is computed almost instantaneously with tripack, but takes significantly longer with interp. An example of a scatter plot that takes a very long time is below. I compared the time it takes for each package to compute the triangulation, including tRiad, the suggested replacement for interp.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(fitzRoy)\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(interp)\nlibrary(cassowaryr)\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n✔ ggplot2 3.4.1     ✔ purrr   0.3.4\n✔ tibble  3.1.8     ✔ stringr 1.5.0\n✔ tidyr   1.2.0     ✔ forcats 0.5.1\n✔ readr   2.1.2     \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n\n```{.r .cell-code}\n# triad is not on CRAN\n# devtools::install_github(\"ZeroDawn0D/tRiad\")\nlibrary(tRiad)\n\n# Get data and find scatter plot that is instant and long scatter plot\naflw <- fetch_player_stats(2020, comp = \"AFLW\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nℹ Fetching match ids\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n✔ Fetching match ids ... done\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nℹ Fetching player stats for \"46 matches\".\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n✔ Fetching player stats for \"46 matches\". ... done\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\n```\n:::\n\n```{.r .cell-code}\naflw_num <- aflw %>%\n  select_if(is.numeric)\n\naflw_num <- aggregate(aflw_num[,5:37],\n                      list(aflw$player.player.player.surname),\n                      mean)\n\n# problem scatter plots\na <- aflw_num$goals\nc <- aflw_num$handballs\n\n# plot it\nplot(a,c)\n```\n\n::: {.cell-output-display}\n![](triadswap_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n\n```{.r .cell-code}\n#Follow code down to tri.mesh \n# to make sure I have the same input\nac <- cbind(cassowaryr:::unitize(a), cassowaryr:::unitize(c))\ndupes <- paste(a, c, sep =\",\")\nac <- ac[!duplicated(dupes),]\nx <- ac\ny = NULL\nX <- xy.coords(x, y)\n\nsystem.time(interp::tri.mesh(X))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n 83.295  11.537 101.154 \n```\n:::\n\n```{.r .cell-code}\nsystem.time(tripack::tri.mesh(X))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRegistered S3 methods overwritten by 'tripack':\n  method                from  \n  plot.voronoi          interp\n  plot.voronoi.polygons interp\n  print.voronoi         interp\n  print.summary.voronoi interp\n  summary.voronoi       interp\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.004   0.001   0.007 \n```\n:::\n\n```{.r .cell-code}\nsystem.time(tRiad::del.tri(X))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.040   0.003   0.042 \n```\n:::\n\n```{.r .cell-code}\nsystem.time(tRiad::DelTri(a,c))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.001   0.000   0.001 \n```\n:::\n:::\n\n\nFor most scatter plots interp performs a faster delauney triangulation than the C++ DelTri function in tRiad. This is only really noticiable when working with scatter plots that have a large number of points.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# small scatter plot\nx <- runif(500)\ny <- runif(500)\nplot(x,y)\n```\n\n::: {.cell-output-display}\n![](triadswap_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n\n```{.r .cell-code}\nsystem.time(tRiad::DelTri(x,y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.004   0.000   0.004 \n```\n:::\n\n```{.r .cell-code}\nsystem.time(interp::tri.mesh(x,y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.003   0.000   0.002 \n```\n:::\n\n```{.r .cell-code}\n# big scatter plot\nx <- runif(5000)\ny <- runif(5000)\nplot(x,y)\n```\n\n::: {.cell-output-display}\n![](triadswap_files/figure-html/unnamed-chunk-2-2.png){width=672}\n:::\n\n```{.r .cell-code}\nsystem.time(tRiad::DelTri(x,y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.159   0.010   0.170 \n```\n:::\n\n```{.r .cell-code}\nsystem.time(interp::tri.mesh(x,y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.107   0.000   0.108 \n```\n:::\n:::\n\n\nFor most plots interp is faster than tRiad, resulting in a lower time on average, however the issue of the occasional *very long* computation time on an interp plot results in a much higher variance. This issue occurs occasionally in simulated continuous data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# set seed\nset.seed(1)\n# set n\nn <- 1000\n  \n# time vector\ntriadtime <- rep(0, n)\ninterptime <- rep(0, n)\n  \n  # run a bunch of times\nfor(i in seq(n)){\n  x <- runif(500)\n  y <- runif(500)\n  triadtime[i] <- system.time(tRiad::DelTri(x,y))[[3]]\n  interptime[i] <- system.time(interp::tri.mesh(x,y))[[3]]\n}\n\n# compare visually\ntimetable <- tibble(\n  triad = triadtime,\n  interp = interptime\n) \nsaveRDS(timetable, file = \"timetable1.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntimetable <- readRDS(file = \"timetable1.rds\")\n\ntimetable %>%\n  pivot_longer(everything(), names_to=\"package\", values_to=\"time\") %>%\n  ggplot(aes(x=package, y=time, colour=package)) +\n  geom_jitter(width=0.5, height=0)\n```\n\n::: {.cell-output-display}\n![](triadswap_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nWhat is of greater concern is that this problem occurs much more frequently in real, non-simulated, data sets.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# interp throws an error without preprocessing, so I'm making an in between function\nprep_interp <- function(x,y){\n  xy <- cbind(cassowaryr:::unitize(x), cassowaryr:::unitize(y))\n  dupes <- paste(x, y, sep =\",\")\n  xy <- xy[!duplicated(dupes),]\n  x <- xy\n  y = NULL\n  X <- xy.coords(x, y)\n  system.time(interp::tri.mesh(X))\n}\n\nprep_triad <- function(x,y){\n  xy <- cbind(cassowaryr:::unitize(x), cassowaryr:::unitize(y))\n  dupes <- paste(x, y, sep =\",\")\n  xy <- xy[!duplicated(dupes),]\n  system.time(tRiad::DelTri(xy[,1],xy[,2]))\n}\n\n# calculate time on collection of scatter plots\naflw_test <- aflw_num[,2:9]\n\ncombinations <- expand.grid(colnames(aflw_test), colnames(aflw_test)) %>%\n    dplyr::filter(!(Var1==Var2))\n\n# Write as a for loop because tidy version was a nightmare to debug\nn <- length(combinations$Var1)\ntriadtime <- rep(0, n)\ninterptime <- rep(0, n)\n\nfor(i in seq(n)){\n  x <- dplyr::pull(aflw_test,var=combinations$Var1[i])\n  y <- dplyr::pull(aflw_test, var=combinations$Var2[i])\n  triadtime[i] <- prep_triad(x, y)[[3]]\n  interptime[i] <- prep_interp(x, y)[[3]]\n}\n\n# put into a tibble and plot\ntimetable <- tibble(\n  triad = triadtime,\n  interp = interptime\n) \n\nsaveRDS(timetable, file = \"timetable2.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntimetable <- readRDS(file = \"timetable2.rds\")\n\ntimetable %>%\n  pivot_longer(everything(), names_to=\"package\", values_to=\"time\") %>%\n  ggplot(aes(x=package, y=time, colour=package)) +\n  geom_jitter(width=0.3, height=0)\n```\n\n::: {.cell-output-display}\n![](triadswap_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nAdditionally the interp package occasionally throws an error on scatter plots that are visually indistinguishable from plots that do not throw an error. These scatter plots work fine\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot that throws an error\nd <- aflw_num$totalPossessions\ne <- aflw_num$contestedPossessions\nplot(d,e)\n```\n\n::: {.cell-output-display}\n![](triadswap_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n\n```{.r .cell-code}\n#Follow code down to tri.mesh \n# to make sure I have the same input\nde <- cbind(cassowaryr:::unitize(d), cassowaryr:::unitize(e))\ndupes <- paste(d, e, sep =\",\")\nde <- de[!duplicated(dupes),]\nx <- de\ny = NULL\nX <- xy.coords(x, y)\n\n# compare methods\nsystem.time(tripack::tri.mesh(X))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.001   0.000   0.001 \n```\n:::\n\n```{.r .cell-code}\nsystem.time(tRiad::DelTri(d,e))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.003   0.000   0.002 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsystem.time(interp::tri.mesh(X))\n```\n:::\n\n\nWhile the faster tRiad triangulation is written in C++, it also has a version of its functions written in R. This makes it easier for the R community to contribute and debug the code. From my understanding of interp, the actual delauney triangulation is computed using the shull.deltri function from the C shull library. So tRiad has additional transparency that interp does not.\n\nDue to the issues with interp caused by computation time, errors, and transparency, I think it would be beneficial to swap the alphahull package to tRiad.\n\n## Changes\n\n### In cassowaryr\n\n### In alphahull\n\n## Do things work?\n\n## Triad issues\n\nGSOC article doesn't work if you try and run the code because it has triad instead of tRiad Readme has library(\"triad\") and I'm not sure if the quotations hurt anything It might be beneficial to allow the tRiad functions to be called in the same way alphahull calls interp. It works for the R version of the function, i.e. tRiad::del.tri(X) runs, but the C++ version of the function does not. Deltri seems to take an infinitely long time if there are duplicate points? Looking at case of aflw behinds vs goals plot. The other methods give an error, I'm not sure what is happening in it since I can't read C++. I'm not sure about the the triad R version.\n",
    "supporting": [
      "triadswap_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}