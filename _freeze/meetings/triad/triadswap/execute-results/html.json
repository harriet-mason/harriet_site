{
  "hash": "49f17f860cbfac2e88d5864123e47c96",
  "result": {
    "markdown": "---\ntitle: \"Replacing interp::tri.mesh() with tRiad::Deltri()\"\neditor: source\nknitr:\n  opts_chunk: \n    warning: FALSE\n    message: FALSE\n---\n\n\n## Motivation for Swap\n\nWhile most scatter plots that had a Delauney triangulation in tripack also have one with interp, there are a handful of scatter plots that do not. These scatter plots take a HUGE amount of time to find the delauney triangulation for no clear reason. This problem is not a feature of the delauney triangulation itself since `tripack::tri.mesh()` is computed almost instantaneously for these plots. I compared the computation time of `interp::tri.mesh()`, `tripack::tri.mesh()`, and `tRiad::Deltri()` (a function written as a replacement for `interp::tri.mesh()` from the package, [tRiad](https://github.com/ZeroDawn0D/tRiad)) on one of these problem scatter plots below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(fitzRoy)\nlibrary(dplyr)\nlibrary(interp)\nlibrary(cassowaryr)\nlibrary(tidyverse)\n# triad is not on CRAN\n# devtools::install_github(\"ZeroDawn0D/tRiad\")\nlibrary(tRiad)\n\n# Get data and find scatter plot that is instant and long scatter plot\naflw <- fetch_player_stats(2020, comp = \"AFLW\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\naflw_num <- aflw %>%\n  select_if(is.numeric)\n\naflw_num <- aggregate(aflw_num[,5:37],\n                      list(aflw$player.player.player.surname),\n                      mean)\n\n# problem scatter plots\na <- aflw_num$goals\nc <- aflw_num$handballs\n\n# plot it\nplot(a,c)\n```\n\n::: {.cell-output-display}\n![](triadswap_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n\n```{.r .cell-code}\n#Follow code down to tri.mesh \n# to make sure I have the same input\nac <- cbind(cassowaryr:::unitize(a), cassowaryr:::unitize(c))\ndupes <- paste(a, c, sep =\",\")\nac <- ac[!duplicated(dupes),]\nx <- ac\ny = NULL\nX <- xy.coords(x, y)\n\n#system.time(interp::tri.mesh(X))\n#system.time(tripack::tri.mesh(X))\n#system.time(tRiad::DelTri(a,c))\n```\n:::\n\n\nFor most scatter plots `interp::tri.mesh()` performs a faster Delauney triangulation than `tRiad::Deltri()`. However, this only really noticeable when working with scatter plots that have a large number of points.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# small scatter plot\nx <- runif(500)\ny <- runif(500)\nplot(x,y)\n```\n\n::: {.cell-output-display}\n![](triadswap_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n\n```{.r .cell-code}\nsystem.time(tRiad::DelTri(x,y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.004   0.000   0.005 \n```\n:::\n\n```{.r .cell-code}\nsystem.time(interp::tri.mesh(x,y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.004   0.001   0.008 \n```\n:::\n\n```{.r .cell-code}\n# big scatter plot\nx <- runif(5000)\ny <- runif(5000)\nplot(x,y)\n```\n\n::: {.cell-output-display}\n![](triadswap_files/figure-html/unnamed-chunk-3-2.png){width=672}\n:::\n\n```{.r .cell-code}\n#system.time(tRiad::DelTri(x,y))\n#system.time(interp::tri.mesh(x,y))\n```\n:::\n\n\nSo, while `interp::tri.mesh()` is usually faster than `tRiad::Deltri()`, the occasional *very long* computation time results in `interp::tri.mesh()`having a much higher variance. This issue occurs occasionally in simulated continuous data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# set seed\nset.seed(1)\n# set n\nn <- 1000\n  \n# time vector\ntriadtime <- rep(0, n)\ninterptime <- rep(0, n)\n  \n  # run a bunch of times\nfor(i in seq(n)){\n  x <- runif(500)\n  y <- runif(500)\n  triadtime[i] <- system.time(tRiad::DelTri(x,y))[[3]]\n  interptime[i] <- system.time(interp::tri.mesh(x,y))[[3]]\n}\n\n# compare visually\ntimetable <- tibble(\n  triad = triadtime,\n  interp = interptime\n) \n# this takes a very long time to compute\nsaveRDS(timetable, file = \"timetable1.rds\") \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntimetable <- readRDS(file = \"timetable1.rds\")\n\ntimetable %>%\n  pivot_longer(everything(), names_to=\"package\", values_to=\"time\") %>%\n  ggplot(aes(x=package, y=time, colour=package)) +\n  geom_jitter(width=0.5, height=0)\n```\n\n::: {.cell-output-display}\n![](triadswap_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nHowever, this problem occurs much more frequently in real, non-simulated, data sets. The problem in non-simulated data is so pronounced, that `interp::tri.mesh()` often takes longer on average than `tRiad::Deltri()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# the functions throws an error without removing duplicates\n# these are just inbetween functions\nprep_interp <- function(x,y){\n  xy <- cbind(cassowaryr:::unitize(x), cassowaryr:::unitize(y))\n  dupes <- paste(x, y, sep =\",\")\n  xy <- xy[!duplicated(dupes),]\n  x <- xy\n  y = NULL\n  X <- xy.coords(x, y)\n  system.time(interp::tri.mesh(X))\n}\n\nprep_triad <- function(x,y){\n  xy <- cbind(cassowaryr:::unitize(x), cassowaryr:::unitize(y))\n  dupes <- paste(x, y, sep =\",\")\n  xy <- xy[!duplicated(dupes),]\n  system.time(tRiad::DelTri(xy[,1],xy[,2]))\n}\n\n# calculate time on collection of scatter plots\naflw_test <- aflw_num[,2:9]\n\ncombinations <- expand.grid(colnames(aflw_test), colnames(aflw_test)) %>%\n    dplyr::filter(!(Var1==Var2))\n\n# Write as a for loop because tidy version was a nightmare to debug\nn <- length(combinations$Var1)\ntriadtime <- rep(0, n)\ninterptime <- rep(0, n)\n\nfor(i in seq(n)){\n  x <- dplyr::pull(aflw_test,var=combinations$Var1[i])\n  y <- dplyr::pull(aflw_test, var=combinations$Var2[i])\n  triadtime[i] <- prep_triad(x, y)[[3]]\n  interptime[i] <- prep_interp(x, y)[[3]]\n}\n\n# put into a tibble and plot\ntimetable <- tibble(\n  triad = triadtime,\n  interp = interptime\n) \n# this also takes a very long time to compute\nsaveRDS(timetable, file = \"timetable2.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntimetable <- readRDS(file = \"timetable2.rds\")\n\ntimetable %>%\n  pivot_longer(everything(), names_to=\"package\", values_to=\"time\") %>%\n  ggplot(aes(x=package, y=time, colour=package)) +\n  geom_jitter(width=0.3, height=0)\n```\n\n::: {.cell-output-display}\n![](triadswap_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nAdditionally the interp package occasionally throws an error on scatter plots that are visually indistinguishable from plots that do not throw an error. These scatter plots have no issues when computed with `tRiad::Deltri()` and `tripack::tri.mesh`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot that throws an error\nd <- aflw_num$totalPossessions\ne <- aflw_num$contestedPossessions\nplot(d,e)\n```\n\n::: {.cell-output-display}\n![](triadswap_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n\n```{.r .cell-code}\n#Follow code down to tri.mesh \n# to make sure I have the same input\nde <- cbind(cassowaryr:::unitize(d), cassowaryr:::unitize(e))\ndupes <- paste(d, e, sep =\",\")\nde <- de[!duplicated(dupes),]\nx <- de\ny = NULL\nX <- xy.coords(x, y)\n\n# compare methods\nsystem.time(tripack::tri.mesh(X))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.004   0.001   0.009 \n```\n:::\n\n```{.r .cell-code}\nsystem.time(tRiad::DelTri(d,e))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.002   0.000   0.003 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#system.time(interp::tri.mesh(X))\n```\n:::\n\n\nAdditionally, while the faster tRiad triangulation is written in C++, it also has a version of its functions written in R, `triad::del.tri()`. This makes it easier for the R community to contribute and debug the code. From my understanding of interp, the actual Delauney triangulation is computed using the `shull.deltri` function from the C shull library. So tRiad has additional transparency that could prevent issues like this in the future.\n\nDue to the issues with `interp::tri.mesh()` caused by computation time, errors, and transparency, I think it would be beneficial to replace the function with `triad::Deltri()`.\n\n## Requirements for Swap\nThere are a lot of very useful functions in interp that are not `tri.mesh()`, and as far as I can tell these functions are very useful and have no issues. Therefore tRiad is not a replacement for the interp package itself. Currently tRiad is not on CRAN, however Umang (the primary author and maintainer of tRiad) is in the process of getting it approved. A bigger issue is that `triad::Deltri()` cannot just replace `interp::tri.mesh()` in it's current state. If we put a version of tRiad on CRAN, we would like it to be a version that does not need any changes to be adopted by interp and alphahull. \n\nCurrently `tRiad::Deltri()` has an output that is identical to neither `interp::tri.mesh()` nor `interp:::shull.deltri(x1,y1)`. If the `Deltri()` output is edited to be the same as `interp:::shull.deltri(x1,y1)`, only the interp package would need to be edited to use tRiad instead of shull. If the `Deltri()` output is edited to be the same as `interp::tri.mesh()`, the interp package would need to adjust `triangles()` to accept the object, and `alphahull::delvor()` to use the triad version of the function. For this reason I think the best choice is to only replace `interp:::shull.deltri()`, even though `tRiad::Deltri()` was written to replace `interp::tri.mesh()`. This means both `tRiad::Deltri()` and `interp::tri.mesh()` need to be edited so the functions are compatible, assuming if everyone is happy to make this change (hopefully).\n",
    "supporting": [
      "triadswap_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}