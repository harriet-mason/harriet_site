---
title: "BEX6510 Assignment"
editor_options: 
  chunk_output_type: console
---

```{r}
#| label: setup
#| echo: false
#| include: false

# Load product plots library
devtools::install_github("hadley/productplots")
library(productplots)
library(tidyverse)
library(patchwork)
library(kableExtra)

happypal <- c("#ff864f","#fcf8ba","#83c84e")
maritalpal <- c("#6BAED6", "#EFF3FF", "#BDD7E7", "#08519C", "#3182BD")
sexpal <- c("#ff7f4e", "#42a8d2")

# Make Version of Data For Histogram Plots
happy_clean <- happy %>% 
  mutate(age = cut(age,
                   breaks = seq(10, 90, 10)))

# Set Up "no gaps" primitive functions
chbar <- function(data, bounds, offset = 0.00, max = NULL){hbar(data, bounds, offset, max)}
```

# Paper's Relevance to My Research

The primary focus of my research is uncertainty visualisation. Uncertainty is seems to be used interchangeably to express the sampling distribution of an estimate and the population distribution of a parameter. Therefore the current work on uncertainty visualisation seems to jump between expressions of a distribution, statistically significant figures, and variance estimates without any justification. The goal of my research is to combine a the existing work on uncertainty visualisation into a well organised framework and then use that framework to identify and fill gaps in our current graphical techniques.

The *Product Plots* connects numerous graphical displays to the statistics that generated each plot. This allows for a systematic and mathematically rigorous approach to understanding the information that exists in a visualisation. Understanding this information is the first step in understanding the connections between existing visualisations and constructing a framework that unites them.

# Summary of Product Plots Paper

## The Main Idea
The main idea of this paper is deceptively simple. The authors propose a connection between the geometric fact that $Area = Width \times Height$ and the statistical fact that $f(x, y) = f(x|y) \times f(y)$. This is both intuitive and mathematically rigorous considering that the concepts of length, area and probability are all born from measure theory. Not only does the method outlined in the paper leverage the multiplicitave relationship between conditional and marginal distributions to represent a joint distribution, but they also leverage the integration of probability density functions $f(x) = \sum_y f(x,y)$ and its relationship to length $position = \sum length$ to make recursive plots. These two methods can be used to simplify visualisations and allow us to break down high dimensional distributions or combine low dimensional distributions.

The paper focuses on the discrete case where we are expressing probability mass functions (PMFs) rather than density functions (PDFs). This restriction allows the authors to translate the discrete probabilities of any PMF into disjoint graphical areas that are. While the paper focuses on categorical variables,  it is important to recognise the paper is not introducing a new way to visualise categorical data, but rather discussing how to break plots down into their statistical elements and understand how they impact the final visualisation.

Data from a happiness survey is used in every plot in the paper, and that data is available with the package `productplots` and it was used to reproduce the figures in this summary. 

**Summary of data**

also have inverse where high dimensional distribution can be factorised into a product of low-dimensional conditional and marginal distributions.

## The R package `productplots`

While the authors leave discussions of the associated R package, `productplots` until the end, I am going to discuss it throughout. My reason for this is two-fold

  1) The structure of the package is helpful in understanding how the product plot breakdown should work, and 
  2) The plots that are made with the package are used throughout the paper and it is easier to understand how the package works when shown along the visualisations it created
  
The main function that the user interacts with to make a product plot and its associated options is `prodplot(data, formula, divider, cascade, scale_max, na.rm, levels)`. Each of the options in the function translates to a different element of the product plot framework. In this summary I will start by discussing the factorization of $f(x,y)$ along with the `data` `formula`, `cascade`, and `levels` arguments. Then I will discuss the graphical primitives of a product plot along with the `divider` and `scale_max` arguments. Finally I will discuss the extensions that can be made to the products plot framework along with its simple implementation due to the graphical primitives being represented by functions (e.g. `hspine()`).

Using the `productplots` framework, every graphic was exactly reproducible (albeit with some difficulties with the code). The paper suggests that the code can be obtained by emailling the authors, however I had no luck on that front, so I had to work out the code that created the graphics by reading the source code of the package. The authors suggest that `prodcalc` is a second main function, however it can safely be ignored when making plots that fit nicely into the product plot framework. 


```{r}
prodplot(happy, ~ happy + finrela + health)
```


# Notes

```{r}
#| label: fig1
#| echo: false
#| fig-cap: "The selection of six plots that make up Figure 1 of the Products Plot paper"

# Common theme
theme_fig1 <- theme(axis.text = element_blank(),
                    axis.ticks = element_blank(),
                    legend.position = "none",
                    panel.grid = element_blank(),
                    axis.title = element_blank(),
                    aspect.ratio = 1)
# Plots
p1 <- prodplot(happy_clean, ~ happy + marital,
         c("vspine", "hspine"), na.rm = TRUE) +
  aes(fill=marital) +
  scale_fill_brewer() +
  theme_fig1

p2 <- prodplot(happy_clean, ~ marital + happy,
         c("tile", "tile"), na.rm = TRUE) +
  aes(fill=marital) +
  scale_fill_brewer() +
  theme_fig1

p3 <- prodplot(happy_clean, ~ marital + happy,
         c("hspine", "vbar"), na.rm = TRUE) +
  aes(fill=marital) +
  scale_fill_brewer() +
  theme_fig1

p4 <- prodplot(happy_clean, ~ marital + happy,
         c("fluct"), na.rm = TRUE) +
  aes(fill=marital) +
  scale_fill_brewer() +
  theme_fig1 

p5 <- prodplot(happy_clean, ~ marital + happy,
         c("hbar", "vbar"), na.rm = TRUE, levels=1:2) +
  aes(fill=marital) +
  scale_fill_manual(values=c(maritalpal)) +
  theme_fig1

p6 <- prodplot(happy_clean, ~ marital + happy,
         c("hbar", "hspine"), na.rm = TRUE, levels=1:2) +
  aes(fill=marital) +
  scale_fill_manual(values=maritalpal) +
  theme_fig1

p1 + p2 + p3 + p4 + p5 + p6
```


## 3 Graphical Primitives

-   area must be proportional to count.
    -   key constraint for area plots
    -   total area is usually constrained
-   partitions must be disjoint.
    -   to be able to see the complete area each rectangle must be not overlapping.
-   partitions must be rectangular
    -   allows many interesting pecterptual tasks to only require comparing lengths or positions along a common scale
    -   these are easier than comparing areas
    -   little evidence rectangles are the best shape for comparison \[15,16\]
-   These constraints give rise to 4 graphical primitives

### 3.1 1d primitives

```{r}
#| label: fig2
#| echo: false
#| fig-cap: "Figure 2 replaication: Graph of three 1d primitives"

# Common Theme
themefig2 <- theme(legend.position = "none",
                   aspect.ratio = 1,
                   axis.text.y = element_blank(),
                   axis.title.y = element_blank())
# Plot 1
p1 <- happy_clean %>%
  prodplot(~ happy, c("hbar"), na.rm=TRUE) + 
  aes(fill=happy) +
  scale_fill_manual(values=happypal) +
  scale_y_continuous(breaks=seq(0,1,1/3)) +
  themefig2

# Plot 2
p2 <- happy_clean %>%
  prodplot(~ happy, c("hspine"), na.rm=TRUE) + 
  aes(fill=happy) +
  scale_fill_manual(values=happypal) +
  scale_y_continuous(breaks=seq(0,1,1/3)) +
  themefig2

# Plot 3
p3 <- happy_clean %>%
  prodplot(~ happy, c("tile"), na.rm=TRUE) + 
  aes(fill=happy) +
  scale_fill_manual(values=happypal) +
  scale_y_continuous(breaks=seq(0,1,1/3)) +
  themefig2 +
  theme(axis.text.x = element_blank())

p1 + p2 + p3
```

-   There are three 1d primitives
    -   bars: height s proportional to value and width is equally divided. Occupy mean(x-max(x)) of the total area *(???)* isnt that the negative of the whitespace?? shouldnt it be mean(X/max(X))
    -   splines: width proportional to value, height occupies full range.
    -   tiles: No restrictions on height and width, just tile the plane with rectangles and try to keep the aspect ratio of each rectangle close to 1. A squarified treemap.
-   Each visualisation has strengths and weaknesses
    -   easy to compare the value associated with bars because comparing position on a common scale
    -   splines and tiles are harder to read but work better reccursively

### 3.2 2d primitives

-   all 2d primitives are created by combining 1d primitives except for one
    -   fluct: has height and width proportional to the square root of the count and is arranged on a rectangular grid formed by the levels of the two variables.
    -   allows comparisons both vertically and horizontally
    -   special case occurs when two variables are jointly uniformly distributed, usually as a result of conditioning. useful for identifying missing combinations

```{r}
#| label: fig3
#| echo: false
#| fig-cap: "Recreation of Figure 3 that shows fluct size and NA identification"

# Set theme
themefig3 <- theme(legend.position = "none",
                   aspect.ratio = 5/8,
                   axis.title = element_blank(),
                   plot.title = element_text(hjust = 0.5))

# Plot 1
p1 <- happy_clean %>%
  prodplot(~ age + marital, c("fluct"), na.rm=TRUE) + 
  aes(fill=marital) +
  scale_fill_brewer() +
  scale_x_continuous(name ="Age",
                     breaks=seq(0,875,0.125)[1:8],
                     labels = levels(happy_clean$age))+
  scale_y_continuous(name ="Marital",
                     breaks=seq(0,0.8,0.2),
                     labels = levels(happy_clean$marital)) +
  themefig3 +
  ggtitle("f(age,marital)")

# Plot 2 **incomplete**
# cant get missings to appear
p2 <- prodplot(happy, ~ 1 | health + year, c("vspine", "hspine"), na.rm=TRUE) +
  aes(fill=health) +
  scale_fill_brewer(palette = 5) +
  themefig3 +
  ggtitle("f(1|age,marital)")

p1/p2
```

## 4 Probabulity and Plot Products

-   To construct plots of higher dimensions we need a way to decompose them into 1d and 2d components.

### 4.1 Joint distribution are the product of marginals and conditionals

```{r}
#| label: fig4
#| echo: false
#| layout-ncol: 2
#| tbl-cap: "Calculations of all the distributions that could be of use when plotting sex against happy"
#| tbl-subcap: ["f(happy,sex)", "f(sex) and f(happy)", "f(sex|happy)", "f(happy|sex)"]


# Calculate Joint
joint <- table(happy$happy, happy$sex)/sum(table(happy$happy, happy$sex))

# Calculate Marginals
happy_marg <- table(happy$happy)/sum(table(happy$happy))
sex_marg <- table(happy$sex)/sum(table(happy$sex))

# Calculate Conditionals
# Sex conditional on happy
sex_cond_happy <- matrix(nrow=3, ncol=2)
for(i in 1:3){
  sex_cond_happy[i,] <-joint[i,]/happy_marg[i]
}
# Happy conditional on sex
happy_cond_sex <- matrix(nrow=3, ncol=2)
for(i in 1:2){
  happy_cond_sex[,i] <-joint[,i]/sex_marg[i]
}

# Make Nice Joint Distribution
as.data.frame.matrix(joint) %>%
  mutate(across(everything(), round, 2)) %>%
  kbl(caption = "f(happy, sex)") %>%
  kable_classic() %>%
  kable_styling(full_width = F)

# Make Nice Marginal Distributions
options(knitr.kable.NA = '')
tibble(male = c(NA,NA,NA,sex_marg[1]),
       female = c(NA,NA,NA,sex_marg[2]),
       total = c(happy_marg, NA)) %>%
  mutate(rownames = c(levels(happy_clean$happy), " ")) %>%
  column_to_rownames(var="rownames") %>%
  mutate(across(everything(), round, 2)) %>%
  rename(` ` = total) %>%
  kbl(caption = "f(sex) and f(happy)") %>%
  kable_classic() %>%
  kable_styling(full_width = F)

# Make Nice Conditional Distributions
cond_redo <- function(x){
  x %>%
    as.data.frame.matrix(x) %>% 
    rename(male = V1, female = V2) %>%
    mutate(happy = levels(happy_clean$happy)) %>%
    column_to_rownames(var="happy") %>%
    mutate(across(everything(), round, 2))
}
cond_redo(sex_cond_happy) %>%
  kbl(caption = "f(sex|happy)", table.attr = "style='width:30%;'") %>%
  kable_classic() %>%
  kable_styling(full_width = FALSE) 
  
cond_redo(happy_cond_sex)%>%
  kbl(caption = "f(happy|sex)")%>%
  kable_classic() %>%
  kable_styling(full_width = FALSE)
```

-   turn data into a PMF
-   Variables are happy and sex are shown in several tables.
-   Joint distribution
    -   Q: what proportion of all people are male and very happy?
-   Conditional distributions
    -   Q: what proportion of males are not too happy?
-   Marginal Distributions
    -   Q: What proportion of respondents were male? What proportion were very happy?
-   Have the equation $f(x|y) = f(x,y)/f(y)$
    -   Therefore given a conditional and a marginal we can find the joint distribution
    -   $f(x,y) = f(x|y)f(y)$
    -   Only the joint distribution contains the full information about the relationship between all variables involved
    -   can get the marginal distribution by integrating/summing the other variable out, i.e. $f(x)=\int_y{f(x,y)}$
    -   These definitions extend to higher dimensions
        -   $f(x,y,z) = f(x,y|z)f(z)$
        -   $f(x,y,z) = f(x|z,y)f(z,y)$
        -   $f(x,y,z) = f(x|y,z)f(y|z)f(z)$
-   Therefore we can build any high dimensional PMF as a product of low-dimensional conditional and marginal PMFs
-   Use low-dimensional primitives as graphical analog of this multiplication

### 4.2 Area is the product of height and width

```{r}
#| label: fig5
#| echo: false
#| warning: false
#| layout-nrow: 2

# Fig 5
# plot 1
# a) copy and paste fig 1 plot 2
p1a <- happy_clean %>%
  prodplot(~ happy, c("hspine"), na.rm=TRUE) + 
  aes(fill=happy) +
  scale_fill_manual(values=happypal) +
  scale_y_continuous(breaks=seq(0,1,1/3)) +
  themefig2
# b 
p1b <- prodplot(happy, ~ sex | happy, c("vspine", "hspine"), na.rm=TRUE) +
  aes(fill=sex) +
  scale_fill_manual(values = sexpal) +
  scale_y_continuous(breaks=seq(0,1,1/3)) +
  themefig2
# c
p1c <- prodplot(happy, ~ sex + happy, c("vspine", "hspine"), na.rm=TRUE) +
  aes(fill=sex) +
  scale_fill_manual(values = sexpal) +
  scale_y_continuous(breaks=seq(0,1,1/3)) +
  themefig2

# plot 2
# a) copy and paste fig 1 plot 1
p2a <- happy_clean %>%
  prodplot(~ happy, c("hbar"), na.rm=TRUE) + 
  aes(fill=happy) +
  scale_fill_manual(values=happypal) +
  scale_y_continuous(breaks=seq(0,1,1/3)) +
  themefig2
# b) copy and paste fig 2 plot 1b
# c
p2c<- prodplot(happy_clean, ~ sex + happy, 
               c("vspine", "hbar"), na.rm=TRUE) +
  aes(fill=sex) +
  scale_fill_manual(values = sexpal) +
  scale_y_continuous(breaks=seq(0,1,1/3)) +
  themefig2

timez <- grid::textGrob("X", just="left")
equals <- grid::textGrob("=")

# w <- grid::grobWidth(timez)
#gridExtra::grid.arrange(p1a, timez, p1b, equals, p1c,
#             widths = grid::unit.c(10*w, w, 10*w, w, 10*w))

#(p1a | timez | p1b | equals | p1c)/
#(p2a | timez | p1b | equals | p2c)

(p1a | p1b | p1c)/
(p2a | p1b | p2c)
```

-   area is also a product so it can be connected
    -   e.g. 1 mosaic plot: height f(sex\|happy) X width = f(happy) = area f(sex, happy)
    -   e.g. 2: stacked bar chart: position f(happy) X proportion f(sex\|happy) = length f(sex, happy) \~ area = c\*f(happy, sex).
-   Algorithm gives a rough idea of computation
    -   calculate one marginal and i conditional distributions
    -   for each probability in the marginal distribution,
        -   divide the probabilities (aka the bounds) into i sets of new bounds, one for each level of the categorical variabe.
        -   if i=1 like in the example we keep the original bounds
        -   for each new bound there is a matching conditional distribution, call the partition function
        -   drop one element from the list of drawing primitives
-   Different partitions reveal different features
    -   Hard to identify if this is because they used splines for both of the first plot but splines and bar for the second plot or because of the different distributions.
    -   $f(marial,age) = f(marital|age)f(age)$ highlights most young people are unmaried
    -   $f(marial,age) = f(age|marital)f(marital)$ highlights few unmarried people over the age of 30
    -   I am also not sure how much I agree with this assessment of what the plots say. I don't disagree with the premise though. I do wonder if that is because both comments are about being unmarried.
-   Conditioning is also a useful tool because it allows us to remove relationships that are known or uninteresting.
    -   Give example of $f(happy, health, financial)$
    -   When show all as raw proportions $f(happy, health, financial)$ = $f(happy| health, financial)f(heath,financial)$ your main take away is that most people are in good health and average financial standing, however it is difficult to see how happiness varies within these conditions
    -   If you condition on health and financial status, comparing happiness across these groups becomes easier because comparing positions along a common scale is an easier perception task.
    -   Depending on the comparison we are most interested in, we can make it easier to compare across different variables

## 5 Existing Plot Types

1D - Bar chart (hbar) - Column chart (vbar) - Spineplot (spine) - Fluctuation chart (fluct) 2D - Stacked bar chart (1hbar and 1vspine) - Nested bar chart (2 hbars) - Equal bin size (1 fluct and 1 vspine) - Mosaic plot (alternating hspine vspine) - Double Decker (n-1 hspines and 1 vspine) - Treemap (n spines) - Squarified treemap (n tiles) - Generalised treemaps (any plot ending with a tile) - Trellis graphics (similar but not identical, created by conditioning in tellising variables)

## 6 Display Considerations

-   Hard to label axis
    -   often two variables end up on the same axis so we cant label it.
    -   there are other ways to label the axis other than colour
        -   e.g. text labels used to occupy the space of the region they label
        -   in the interactive setting can have linked brushing from high dimensional to low dimensional plots
        -   some apsect ratios are more aesthetically pleasing, e.g. the square for the fluct. wonder if aspect ratios close to the golden ratio might be more appealing
        -   does not seem to be previous work on aspect ratios and aesthetics although they do seem to affect perception
        -   need more research on aesthetics and usability

## Variations and Extensions

### 7.1 Weighting

-   instead of counts can plot weighted data
-   i.e. redo plots where the data is weighted because of sampling or some other reason
-   weights are also useful to move from number of countries to number of people \### 7.2 Continuous Data
-   instead of counts can plot continuous data
-   trivially extended by binning the continuous data to make them discrete
    -   can do bins of equal width OR bins containing an equal number of points
-   extension allows product plots to also describe histograms and spinograms
    -   no gaps are displated between adjacent rectangles when displaying continuous data
-   more theoretical approach is to increase number of bins infintesimally leading to a probability density function
    -   approach can include one continuous variable but two variables need an additional aesthetic such as colour to visualise a 2d joint density.

    -   

        > =3 continuous variables breaks the product plots framework

    -   if you express the innersmost proportion with colour (instead of area) can describe dimensional stacking (apparently a SPLOM is dimensional stacking)

### 7.3 Area not proportional to weight

-   relax display constraints
-   to distinguish between zeros, missing values, and very small values
-   zero weight should have zero area but instead set it to be at a minimum perceptible size.
    -   set as a different colour to let the reader know the area=weight rule is violated
-   could also be useful to restrict max value so you can see other small values
-   could also do other non linear transformations
    -   e.g. Tukey applied the technique to histograms where the y axis has a square root scale

### 7.4 Non-disjoint partitions

-   relax display constraints
-   e.g. cascaded treemaps
-   makes it easier to see all the levels of the hierarchy and highlights the structure
    -   e.g. each of $f(sex)$, $f(marital, sex)$, and $f(happy|sex, marital)$ get a layer.
    -   hard to tell when something is $f(X|Y)$ or $f(X,Y)$

### 7.5 Non-rectangular partitions

-   relax display constraints
-   pie chart not retangular and does not fall into the framework, but it does relate
    -   it is a hspline draw in polar coodinates with the x-coordinate mapped to angle and the y coordinate mapped to radius
-   Other plots that are product plots drawn in polar coodinates
    -   Wind rose and fourfold displays (1 hbar and 1 vspine)
        -   Nightingales coxcomb is similar but the slices overlap so it violates the disjoint area constraint
    -   Concentric pie chart (1 hspine)
    -   Doughnut plot (1hspine and 1 vspine)
    -   Racetrack plot (1 vbar)
    -   Infoslides (n vbars)
-   research suggests that visualisations in polar coordinates are harder to read that visualisations in cartesian coordinates
-   y-axis must be square root transformed to ensure that counds stay proportional to areas
    -   Fan-lenses and Stasko's radial displays deliberatrely do not do this to emphasise the outer levels.
-   Other non-rectangular graphics
    -   circular treemaps
    -   space-filling curves
    -   voronoi treemaps

## 9 Conclusion

-   Framework is successful at describing many existing graphics that display tables of counts, proportions and probabilities
-   framework leads to many possibilities as a 4d PMF can be factorised in 5 different ways, with 24 different ways of ordering the variables. Have 5 yeas of displaying a 1d PMF and 1 way of displaying a 2D pmf
    -   defines a large space of potential plots. Have $24*(5^4+5^2+5^2+5^2+1)=16824$ plots before we consider conditioning
    -   IDK where that number came from
        -   on the function end:
            -   24 combinations of variables
            -   5 ways of factorising
            -   24\*5 different factorisations
            -   5 ways of displaying a 1D PMF
                -   within the factorisations there are (4, 2, 2, 2, 0) 1D PMFs
            -   1 way of displaying a 2D pmf
                -   within the factorisations there are (0, 1, 1, 1, 2)
                -   it looks like it is done $5*5*5*5$ $5*5*1$ $5*1*5$ $1*5*5$ $1*1$
-   Well thought out interactions make it easier to navigate this space & developed a prototype as part of the cranvas suite of interactive grahics
-   also exploring the connection between product plots and log-linear (AKA poisson) models (the statistical models most commonly used for count data)
    -   e.g. looking for straight lines in a mosaic plot corresponds to a formal test of independence between variables
    -   generally we are interested in connections between visualisation and formal statistical tests
    -   also how significant coefficients can help us choose a set of useful plots
    -   given a question can we select appropriate plots? given a plot can we suggest questions it might answer?
-   Product plots need to be extension to display uncertainty
-   Continuous data is incorperated in a simplistic manner.
    -   can it be extended for something like the average shifted histogram or the kernel density estimate

# Personal notes

-   The distinction between conditional and joint seems to be very blurry and coding the distributions makes this even more confusing
    -   also makes the number of permutations a little odd because it doesn't quite seem to work how they suggest
-   Cant make weighted data plots in their thing

# Unsorted Code

```{r}



# Fig 6
# plot 1
prodplot(happy_clean, ~ marital, c("hspine")) + 
  aes(fill=marital) +
  scale_fill_brewer() +
  theme(legend.position = "none",
        aspect.ratio = 1,
        axis.text.y = element_blank())
# plot 2
  # calculate breaks
x = table(happy$marital)/sum(table(happy$marital))
y = cumsum(x)
marital_breaks2 = as.vector(y - 0.5*x)
  # plot
prodplot(happy_clean, ~ sex + marital, c("hspine", "hspine")) + 
  aes(fill=sex) +
  scale_fill_brewer(palette = 5, type = "qual") +
  theme(legend.position = "none",
        aspect.ratio = 1,
        axis.text.y = element_blank()) +
  scale_x_continuous(name ="Marital",
                     breaks= marital_breaks2,
                     labels = levels(happy_clean$marital))
# plot 3
prodplot(happy_clean, ~ happy + sex + marital, 
         c("vspine", "hspine", "hspine")) + 
  aes(fill=happy) +
  scale_fill_brewer(palette = 5, type = "qual") +
  theme(legend.position = "none",
        aspect.ratio = 1,
        axis.text.y = element_blank())+
  scale_x_continuous(name ="Marital",
                     breaks= marital_breaks2,
                     labels = levels(happy_clean$marital))

# Figure 7
# plot 1
prodplot(happy_clean, ~ marital + age, c("vspine", "hspine")) +
  aes(fill=marital) +
  scale_fill_brewer() +
  theme(legend.position = "none", aspect.ratio = 1,
        axis.text.y = element_blank())
# plot 2
# quick
prodplot(happy_clean, ~ age + marital, c("chbar", "vspine"),
         levels=1:2, na.rm=TRUE) +
  aes(fill=marital) +
  scale_fill_brewer() +
  theme(legend.position = "none")

# long in next chunk
# should have been
prodplot(happy_clean, ~ age + marital, c("hspine", "vspine")) +
  aes(fill=age) +
  scale_fill_brewer() +
  theme(legend.position = "none", aspect.ratio = 1,
        axis.text.y = element_blank()) +
  scale_y_continuous(name = "Marital",
                     breaks=seq(0.1,0.9,0.2),
                     labels = levels(happy_clean$marital))

# Figure 8
# Plot 1
prodplot(happy, ~ happy + finrela + health,
         c("vspine", "fluct"), na.rm = TRUE) + 
  aes(fill=happy) +
  scale_fill_manual(values = happypal) +
  theme(aspect.ratio = 5/4,
        legend.position = "none") +
  # The fluct axis breaks should be evenly spaced
  scale_x_continuous(breaks=seq(0,0.75,0.25),
                     labels = levels(happy$health))+
  scale_y_continuous(breaks=seq(0,0.8,0.2),
                     labels = levels(happy$finrela))

# Plot 2
prodplot(happy, ~ happy | finrela + health,
         c("vspine", "fluct"), na.rm = TRUE)  + 
  aes(fill=happy) +
  scale_fill_manual(values = happypal) +
  theme(aspect.ratio = 5/4,
        legend.position = "none") +
  # these axis are centered for some reason
  scale_x_continuous(breaks=seq(0.125,0.875,0.25),
                     labels = levels(happy$health))+
  scale_y_continuous(breaks=seq(0.1,0.9,0.2),
                     labels = levels(happy$finrela))

# Plot 3
prodplot(happy, ~ happy | finrela + health,
         c("hspine", "fluct"), na.rm = TRUE)  + 
  aes(fill=happy) +
  scale_fill_manual(values = happypal) +
  theme(aspect.ratio = 5/4,
        legend.position = "none") +
  # these axis are centered for some reason
  scale_x_continuous(breaks=seq(0.125,0.875,0.25),
                     labels = levels(happy$health))+
  scale_y_continuous(breaks=seq(0.1,0.9,0.2),
                     labels = levels(happy$finrela))

# Figure 9
prodplot(happy_clean, ~ sex + age,
         c("vspine", "hbar"), na.rm = TRUE) +
  aes(fill=sex)
# weighted plot
prodplot(happy_clean, wtsall ~ sex + age,
         c("vspine", "hbar"), na.rm = TRUE) +
  aes(fill=sex)

# Figure 10
prodplot(happy_clean, ~ happy + age,
         c("vspine", "hbar")) +
  aes(fill=happy) +
  scale_fill_manual(values = happypal)
prodplot(happy_clean, ~ happy + age,
         c("vspine", "hspine")) +
  aes(fill=happy) +
  scale_fill_manual(values = happypal)

# Figure 11
prodplot(happy_clean, ~ happy + marital + sex , 
         c("vspine", "hspine", "hspine"), na.rm=TRUE,
         cascade=0) + 
  aes(fill=happy) +
  scale_fill_manual(values =happypal) +
  theme(legend.position = "none",
        aspect.ratio = 1)

prodplot(happy_clean, ~ happy + marital + sex , 
         c("vspine", "hspine", "hspine"), na.rm=TRUE,
         cascade=0.15, levels=1:3, colour="black", alpha=0.6) + 
  aes(fill=happy) +
  scale_fill_manual(values = happypal) +
  theme_minimal() +
  theme(legend.position = "none",
        aspect.ratio = 0.75) 

# Fig 12 (a lot of these are not quite right)
prodplot(happy, ~ sex + happy , 
         c("hbar", "hbar"), na.rm=TRUE, levels=1:2) +
  aes(fill=sex) +
  # Plot b
  #coord_polar(theta = "x", start = 0, direction = 1, clip = "on") +
  # Plot c
  #coord_polar(theta = "y", start = 0, direction = 1, clip = "on") +
  scale_fill_manual(values = sexpal) 


prodplot(happy, ~ sex + happy , 
         c("vspine", "hbar"), na.rm=TRUE, levels=1:2) +
  aes(fill=sex) +
  # Plot b
  #coord_polar(theta = "x", start = 0, direction = 1, clip = "on") +
  # Plot c
  #coord_polar(theta = "y", start = 0, direction = 1, clip = "on") +
  scale_fill_manual(values = sexpal)

prodplot(happy, ~ sex + happy , 
         c("hspine", "hspine"), na.rm=TRUE, levels=1:2) +
  aes(fill=sex) +
  # Plot b
  #coord_polar(theta = "x", start = 0, direction = 1, clip = "on") +
  # Plot c
  coord_polar(theta = "y", start = 0, direction = 1, clip = "on") +
  scale_fill_manual(values = sexpal) 

prodplot(happy, ~ sex + happy , 
         c("hspine", "hspine"), na.rm=TRUE) +
  aes(fill=sex) +
  # Plot b
  coord_polar(theta = "x") +
  # Plot c
  coord_polar(theta = "y") +
  scale_fill_manual(values = sexpal) 

prodplot(happy, ~ sex + happy , 
         c("vspine", "hspine"), na.rm=TRUE) +
  aes(fill=sex) +
  # Plot b
  coord_polar(theta = "x", start = 0, direction = 1) +
  # Plot c
  coord_polar(theta = "y", start = 0, direction = 1) +
  scale_fill_manual(values = sexpal) 
```

```{r}
#| eval: false
# Fig 7 Attempt
library(dplyr)
marital_mins <- tibble(marital = levels(happy$marital),
                       ymin = c(0,as.vector(y)[1:4]))
age_mins <- tibble(age = levels(happy_clean$age),
                   xmin = seq(0,0.875,0.125),
                   xmax = seq(0.125,1,0.125))

# make joint...
joint <- table(happy_clean$age, happy_clean$marital)/sum(table(happy_clean$happy, happy_clean$sex))
# ... and marginal distribution
marital_mar <- table(happy$marital)/sum(table(happy$marital))
# find value to scale histograms by
max_joint <- apply(joint,2,max)
scale <- min(marital_mar/max_joint)

# find positions for age polygon
positions <- as.data.frame.matrix(joint) %>%
  rownames_to_column("age") %>%
  pivot_longer(cols=-age, names_to = "marital")  %>%
  left_join(marital_mins) %>%
  left_join(age_mins) %>%
  mutate(ymax = ymin + value*scale) %>%
  rownames_to_column("id") %>%
  select(-value) %>%
  pivot_longer(cols=c(xmin,xmax), names_to = "xid", values_to = "x") %>%
  pivot_longer(cols=c(ymin,ymax), names_to = "yid", values_to = "y")

# need to swap rows 3 and 4 of each polygon
fouth <- seq(from=4, to=length(positions$x), by=4)
third <- even - 1
xholder <- positions$x
yholder <- positions$y
positions$x[third] <- xholder[fouth]
positions$x[fouth] <- xholder[third]
positions$y[third] <- yholder[fouth]
positions$y[fouth] <- yholder[third]

# marital positions
big_positions <- tibble(marital = rep(levels(happy$marital), each=4),
                        y = rep(c(0,rep(as.vector(y)[-5], each=2), 1), each=2),
                        x = rep(c(0,1,1,0),5))

# Finally make plot
ggplot() +
  geom_polygon(data = big_positions, aes(x = x, y = y, fill = marital, group = marital), colour="black") +
  geom_polygon(data = positions, aes(x = x, y = y, fill = marital, group = id), colour="black")  +
  scale_fill_brewer() +
  scale_x_continuous(name = "Age",
                     breaks= seq(0,0.875,0.125)+0.125*0.5,
                     labels = levels(happy_clean$age))+
  scale_y_continuous(name = "Marital",
                     breaks= marital_breaks2,
                     labels = levels(happy_clean$marital)) +
  theme(legend.position = "none",
        aspect.ratio = 1.25)


```

## R Code Issue List

-   If I use scale_fill_brewer() instead of scale_fill_manual() I get a clear background instead of the grey background.
-   Axis need to be rescaled and labeled with scale_x_continuous. The ticks are evenly spaced out so they are easy to recalculate and label. Default has weird axis.
-   need to set aspect ratio to #categoriesY/#categoriesX to keep flux plot as squares.
-   Couldnt really get NA values to appear in Figure 3. I don't know how the paper got those gaps.

# Extension of Work

-   Does this work extend to expected values or visualisations of other mathematical process?
-   Could be expanded by looking at which other perceptual tasks are combinations of others
-   extension to continuous case
-   Can the questions be combined similarly the way we can combine the PMF and the graphics
-   Connections between formal statistical tests and visualisations
-   uncertainty visualisation extensions
-   other geometric measures (curvature)

# Minor Mistakes
- Fig 5 has an = sign instead of a multiplication 