---
title: "BEX6510 Assignment"
editor_options: 
  chunk_output_type: console
execute:
  echo: false
  warning: false
---

```{r}
#| label: setup
#| echo: false
#| include: false

# Load product plots library
# devtools::install_github("hadley/productplots")
library(productplots)
library(tidyverse)
library(patchwork)
library(kableExtra)

happypal <- c("#ff864f","#fcf8ba","#83c84e")
maritalpal <- c("#6BAED6", "#EFF3FF", "#BDD7E7", "#08519C", "#3182BD")
sexpal <- c("#ff7f4e", "#42a8d2")

# Make Version of Data For Histogram Plots
happy_clean <- happy %>% 
  mutate(age = cut(age, breaks = seq(10, 90, 10)),
         happy2 = happy,
         constant = 1)

# Set Up "no gaps" primitive functions
chbar <- function(data, bounds, offset = 0.00, max = NULL){hbar(data, bounds, offset, max)}
cvspine <- function(data, bounds, offset = 0.00, max = NULL){vspine(data, bounds, offset, max)}
chspine <- function(data, bounds, offset = 0.00, max = NULL){hspine(data, bounds, offset, max)}

# Calculation of Marigal marginal for Axis Adjustments
marital_marg = table(happy$marital)/sum(table(happy$marital))
```

# Paper's Relevance to My Research

The primary focus of my research is uncertainty visualisation. Uncertainty is seems to be used interchangeably to express the sampling distribution of an estimate and the population distribution of a parameter. Therefore the current work on uncertainty visualisation seems to jump between expressions of a distribution, statistically significant figures, and variance estimates without any justification. The goal of my research is to combine a the existing work on uncertainty visualisation into a well organised framework and then use that framework to identify and fill gaps in our current graphical techniques.

The *Product Plots* connects numerous graphical displays to the statistics that generated each plot. This allows for a systematic and mathematically rigorous approach to understanding the information that exists in a visualisation. Understanding this information is the first step in understanding the connections between existing visualisations and constructing a framework that unites them.

# Summary of Product Plots Paper

## The Main Idea
The main idea of this paper is deceptively simple. The authors propose a connection between the geometric fact that $Area = Width \times Height$ and the statistical fact that $f(x, y) = f(x|y) \times f(y)$. This is both intuitive and mathematically rigorous considering that the concepts of length, area and probability are all born from measure theory. Not only does the method outlined in the paper leverage the multiplicitave relationship between conditional and marginal distributions to represent a joint distribution, but they also leverage the integration of probability density functions $f(x) = \sum_y f(x,y)$ and its relationship to length $position = \sum length$ to make recursive plots. These two methods can be used to simplify visualisations and allow us to break down high dimensional distributions or combine low dimensional distributions.

The paper focuses on the discrete case where we are expressing probability mass functions (PMFs) rather than density functions (PDFs). This restriction allows the authors to translate the discrete probabilities of any PMF into disjoint graphical areas that are. While the paper focuses on categorical variables,  it is important to recognise the paper is not introducing a new way to visualise categorical data, but rather discussing how to break plots down into their statistical elements and understand how they impact the final visualisation.

Data from a happiness survey is used in every plot in the paper, and that data is available with the package `productplots` and it was used to reproduce the figures in this summary. 

**Summary of data**

also have inverse where high dimensional distribution can be factorised into a product of low-dimensional conditional and marginal distributions.

## The R package `productplots`

While the authors leave discussions of the associated R package, `productplots` until the end, I am going to discuss it throughout. My reason for this is two-fold

  1) The structure of the package is helpful in understanding how the product plot breakdown should work, and 
  2) The plots that are made with the package are used throughout the paper and it is easier to understand how the package works when shown along the visualisations it created
  
The main function that the user interacts with to make a product plot and its associated options is `prodplot(data, formula, divider, cascade, scale_max, na.rm, levels)`. Each of the options in the function translates to a different element of the product plot framework. In this summary I will start by discussing the factorization of $f(x,y)$ along with the `data` `formula`, `cascade`, and `levels` arguments. Then I will discuss the graphical primitives of a product plot along with the `divider` and `scale_max` arguments. Finally I will discuss the extensions that can be made to the products plot framework along with its simple implementation due to the graphical primitives being represented by functions (e.g. `hspine()`).

Using the `productplots` framework, every graphic was exactly reproducible (albeit with some difficulties with the code). The paper suggests that the code can be obtained by emailling the authors, however I had no luck on that front, so I had to work out the code that created the graphics by reading the source code of the package. The authors suggest that `prodcalc` is a second main function, however it can safely be ignored when making plots that fit nicely into the product plot framework. 

The product plots in the paper also have a considerable amount of code that adjusts the appearance of the plot, so using the package as is will not produce plots that look identical to those in the paper. I have elected to present the plots in this report without adding colour or cleaning up the axis where possible, to show the package as it comes and to avoid confusing the product plot concept with the addition of extra visual elements, such as colour. That being said I was able to construct all the plots from the paper and they appear in the appendix for the sake of completeness.

## Graphical Primitives
In order to graphically present a probability there are some restrictions the authors establish. 
  1) The area must be proportional to the count
  2) Partitions must be disjoint so that the complete area of each is visible
  3) Partitions must be rectangular so that the the primary perceptual tasks are comparing lengths or positions along a common scale.
The product plot paper suggests that these restrictions give rise to four graphical primitives that make up the product plots. These four graphical primitives are shown in @fig2.

- *Spines*: the width of is proportional to the probability and the height takes up the full range. Spines set each axis to be its own probability function which means each axis must add up to 1 and the total area adds up to 1.
- *Bars*: height (or position along a common scale) is proportional to value and the width is equally divided. The total area of the chart does not equal a probability of 1, the total area of the bars do. 
- *Tiles*: area is proportional to value. The axis of this plot don't have meaning, the plot just tiles the 2d plane with rectangles and tries to keep the aspect ratio of each rectangle close to 1. The total area of the chart equals a probability of 1.
- *Fluct*: area is proportional to the value. A fluct diagram is a collection of squares arranged on a rectangular grid that each have a height and width is proportional to the square root of the probability. The total area of the chart does not equal a probability of 1, the total area of the bars do. 

All 2d primitives (i.e. plots of two varibles $f(x,y)$) are created by combining 1d primitives. The product plots paper suggests that a fluct is a 2d primitive (and needs two data inputs), however it is not clear why this is the case. There does not seem to be anything about the general idea of the fluct (a set of organised areas) that prevents us from using the fluct in same way as a bar chart, so the fluct plot in @fig2 displays the 1d case of that graphical primitive.

Each of these visualisations have their own strengths and weaknesses. Bars allow comparisons along a common scale which is the easiest perceptual task. Spines and tiles are harder to read but work better recursively. Flucs allow comparisons both vertically and horizontally (in the 2d case).
    
```{r}
#| label: fig2
#| echo: false
#| fig-cap: "Figure 2 replaication: Graph of three 1d primitives"
#| fig-subcap: ["Bars", "Spines", "Tiles", "Fluct"]
# Common Theme
themefig2 <- theme(legend.position = "none",
                   aspect.ratio = 1,
                   axis.text.y = element_blank(),
                   axis.title = element_blank())
# Plot 1
p1 <- happy_clean %>%
  prodplot(~ happy, c("hbar"), na.rm=TRUE) + 
  aes(fill=happy) +
  scale_fill_manual(values=happypal) +
  scale_y_continuous(breaks=seq(0,1,1/3)) +
  themefig2

# Plot 2
p2 <- happy_clean %>%
  prodplot(~ happy, c("hspine"), na.rm=TRUE) + 
  aes(fill=happy) +
  scale_fill_manual(values=happypal) +
  scale_y_continuous(breaks=seq(0,1,1/3)) +
  themefig2

# Plot 3
p3 <- happy_clean %>%
  prodplot(~ happy, c("tile"), na.rm=TRUE) + 
  aes(fill=happy) +
  scale_fill_manual(values=happypal) +
  scale_y_continuous(breaks=seq(0,1,1/3)) +
  themefig2 +
  theme(axis.text.x = element_blank())

p4 <- prodplot(happy_clean, ~ happy + constant, c("fluct"), na.rm=T) + 
  aes(fill=happy) +
  scale_fill_manual(values = happypal) +
  theme(aspect.ratio = 1/3,
        legend.position = "none",
        axis.text.y = element_blank()) +
  # The fluct axis breaks should be evenly spaced
  scale_x_continuous(breaks=seq(0,0.66,0.33),
                     labels = levels(happy$happy))
  #scale_y_continuous(breaks=seq(0,0.66,0.33),labels = levels(happy$happy))
p1 + p2 + p3 + p4
```

The graphical primitive is selected with the `divider` option in the `productsplot`package.

## Probability
Every PMF with two or more variables can be factorised into at least two lower level distributions. The product plots paper illustrates this using the joint distribution of $f(sex,happiness)$ and its associated marginal and conditional distributions. The distribution, $f(sex,happiness)$ contains more information than the marginal and conditional distributions and the joint distribution can be used to find the two lower level distributions.

The example provided in the product plots paper can be easily replicated using the `happy` data from the `productplots` package and is shown in @fig4. The proportions in the joint distribution are found by counting the number of people that appear in each possible union of $happy \cap sex$. You can use the joint distribution to find the other distributions by using the relationships $\sum_{sex} f(happy,sex)= f(happy)$ and $\frac{f(happy,sex)}{f(happy)} = f(happy|sex)$ (and vice-versa for finding the marginal distribution of sex and the distribution of sex conditional on happiness). As well as breaking down distributions, conditioning is also useful because it allows us to remove uninteresting relationships.

```{r}
#| label: fig4
#| echo: false
#| layout-ncol: 2
#| tbl-cap: "Calculations of all the distributions that could be of use when plotting sex against happy"
#| tbl-subcap: ["f(happy,sex)", "f(sex) and f(happy)", "f(sex|happy)", "f(happy|sex)"]


# Calculate Joint
joint <- table(happy$happy, happy$sex)/sum(table(happy$happy, happy$sex))

# Calculate Marginals
happy_marg <- table(happy$happy)/sum(table(happy$happy))
sex_marg <- table(happy$sex)/sum(table(happy$sex))

# Calculate Conditionals
# Sex conditional on happy
sex_cond_happy <- matrix(nrow=3, ncol=2)
for(i in 1:3){
  sex_cond_happy[i,] <-joint[i,]/happy_marg[i]
}
# Happy conditional on sex
happy_cond_sex <- matrix(nrow=3, ncol=2)
for(i in 1:2){
  happy_cond_sex[,i] <-joint[,i]/sex_marg[i]
}

# Make Nice Joint Distribution
as.data.frame.matrix(joint) %>%
  mutate(across(everything(), round, 2)) %>%
  kbl(caption = "f(happy, sex)") %>%
  kable_classic() %>%
  kable_styling(full_width = F)

# Make Nice Marginal Distributions
options(knitr.kable.NA = '')
tibble(male = c(NA,NA,NA,sex_marg[1]),
       female = c(NA,NA,NA,sex_marg[2]),
       total = c(happy_marg, NA)) %>%
  mutate(rownames = c(levels(happy_clean$happy), " ")) %>%
  column_to_rownames(var="rownames") %>%
  mutate(across(everything(), round, 2)) %>%
  rename(` ` = total) %>%
  kbl(caption = "f(sex) and f(happy)") %>%
  kable_classic() %>%
  kable_styling(full_width = F)

# Make Nice Conditional Distributions
cond_redo <- function(x){
  x %>%
    as.data.frame.matrix(x) %>% 
    rename(male = V1, female = V2) %>%
    mutate(happy = levels(happy_clean$happy)) %>%
    column_to_rownames(var="happy") %>%
    mutate(across(everything(), round, 2))
}
cond_redo(sex_cond_happy) %>%
  kbl(caption = "f(sex|happy)", table.attr = "style='width:30%;'") %>%
  kable_classic() %>%
  kable_styling(full_width = FALSE) 
  
cond_redo(happy_cond_sex)%>%
  kbl(caption = "f(happy|sex)")%>%
  kable_classic() %>%
  kable_styling(full_width = FALSE)
```

While these lower level distributions can be constructed, the types of questions they can be used to answer are different. Joint distributions answer *X and Y* questions (e.g. what proportion of all people are *male and happy*), conditional distributions answer *X given Y* questions (e.g. what proportion of *men people are happy*) and marginal distributions answer *X or Y* questions (e.g. what proportion of *people are male*). 

We connect the concept of probability to the graphical primitives through the factorisation of age as $age=length \times width$. The paper suggests that different partitions reveal different features of our data. The paper suggests that $f(marial,age) = f(marital|age)f(age)$ highlights the fact that most young people are unmarried, while $f(marial,age) = f(age|marital)f(marital)$ highlights that there are few unmarried people over the age of 30. Unfortunately it is hard to identify in the plot they presented (Figure 7 in the paper) because the authors changed the graphical primitives as well as the factorisation. @fig7 shows the two different factorisations using the same graphical primitives. This example is still difficult to verify because what is visually meant by "there are few unmarried people over the age of 30" or "most young people are unmarried" is hard to identify. The interchangeability of these sentances also does not help.

```{r}
#| echo: false
#| label: fig7
#| fig-cap: Comparison of diferent factorisations of f(age,marital).
#fig-subcap: ["f(marital|age)f(age)", "f(age|marital)f(marital)"]

# plot 1
p1 <- prodplot(happy_clean, ~ marital + age, c("vspine", "hspine")) +
  aes(fill=marital) +
  scale_fill_brewer() +
  theme(legend.position = "none", aspect.ratio = 1,
        axis.text.y = element_blank())
# plot 2
p2 <- prodplot(happy_clean, ~ age + marital, c("hspine", "vspine")) +
  aes(fill=marital) +
  scale_fill_brewer() +
  theme(legend.position = "none", aspect.ratio = 1,
        axis.text.y = element_blank()) +
  scale_y_continuous(name = "Marital",
                     breaks=seq(0.1,0.9,0.2),
                     labels = levels(happy_clean$marital))
p1 + p2
```

Expressing a distribution in the product plot package is simple, but not explained in the paper, nor in the documentation of the associated package. It can only be identified through trial and error, or by reading the source code. The `formula` argument should take something in the form of `Weighting ~ Marginal | Conditional`. Where the marginal distribution is always factorised where if `Marginal= x + y` then the plot displayed is $f(x,y)=f(y)f(x|y)$. This extends to higher dimensions with `Marginal = x + y + z` is displayed as $f(x,y,z)=f(y,z)f(x|y,z)$.

# Existing Plot Types
It turns out there are a large number of plots that are simply specific cases of the general product plot framework. The vast number of plots that can be constructed using a simple frameworks highlights the importance of developing a strong understanding of the building blocks of plotting and probability before jumping in to developing new plots. 

The connections between the product plot framework and existing plots are shown in @figcharts. There are many charts that can be considerd a product of the product plots framework without loosening any restrictions. There are a few others that are related and can be found by relaxing one or more of the restrictions. Plots that are not certainty connects (i.e. it has not be proven) do not have their product plot equivalent listed. It is interesting how many plots that are typically considered distinct are an extension of a simple framework.

```{r}
#| echo: false
# Normal plots
charts1 <- c("Bar chart/Histogram", "Column chart","Spineplot", "Spinograms", "Fluctuation chart","Stacked bar chart","Nested bar chart", "Equal bin size","Mosaic plot","Double Decker","Treemap","Squarified treemap","Generalised treemaps")
comparisons1 <- c("1 hbar","vbar","1 spine", "1 hbar and 1 hspine","1 fluct","1 hbar and 1 vspine","2 hbars","1 fluct and 1 vspine","alternating hspine vspine","n-1 hspines and 1 vspine","n spines","n tiles","any plot ending with a tile")
t1 <- tibble(Chart = charts1,
             `Product plot` = comparisons1) %>%
  kbl() %>%
  kable_classic() %>%
  kable_styling(full_width = F)

# Relax restraints
charts2 <- c("Pie Chart", "Wind rose and fourfold displays", "Concentric pie chart", "Doughnut plot", "Racetrack plot", "Infoslides", "Fan-lenses", "Stasko's radial displays", "Circular treemaps", "Space-filling curves", "Voronoi treemaps","Nightingales coxcomb", "Cascaded treemaps")
relaxed2 <- c(rep("Rectangular (polar co-ordinates)",11), "Rectangular (polar co-ordinates) & Disjoint partitions", "Disjoint partitions")
comparisons2 <- c("1 hspine", "1 hbar and 1 vspine", "1 hspine", "1hspine and 1 vspine", "1 vbar", "n vbars", rep("", 7))

t2 <- tibble(Chart = charts2,
             `Relaxed constraint`= relaxed2,
             `Product plot` = comparisons2) %>%
  kbl() %>%
  kable_classic() %>%
  kable_styling(full_width = F)

t1
t2
```

# Extensions to the product plot framework
## A Better Understanding
My further addition to this paper is a general refinement of this idea that leads to a and a clear explanation of why this cannot be extended to the continuous case. The main idea behind the paper, that we are directly connecting the mathematical statement $f(x,y)=f(x)f(x|y)$ to the geometric statement $area=length \times width$ is false.

If we used the $area=length \times width$ fact every time we wanted to add on a variable, the product plot framework would need to add a new axis every time we broke down the factorisation to a lower level. This translates to a plot being 

The fundamental idea of product plots is that a plot of $f(x,y)$ can be expressed by setting one axis to be $f(x)$ and the other to $f(y|x)$. While the two variable case is obvious in how they display the variables, the single variable and higher dimensional cases are less obvious. The single case variables still take up a two dimensional plot, so along with the joint distribution factorisation we have three factorisations that make the building blocks of the product plots framework.
  - $f(x) = f(x)*1$
  - $f(x|y) = f(x|y)\times y$ where $n$ is the number of categories in the variable $y$. 
  - $f(x,y)=f(x)f(y|x)$

Threee example plots of these factorisations are shown in @figfundamentals and the lengths along the axis can be directly taken from the tables in @fig4. Of course the paper does not make this fundamental breakdown of the single variable distributions explicit, but understanding that every axis is cut into lengths on the basis of some probability mass function (even if it is a constant PMF) makes understanding the process in higher dimensions much easier. @figfundamentals also highlights that the way the factorization connects to the plot is not just by "adding plots together" or "adding a new width" but through axis replacement. 

```{r}
#| label: figfundamentals
#| echo: false
#| warning: false
#| caption: This figure shows the product plot version of f(happy) and f(sex|happy). The axis have been adjusted to highlight the distribution that breaks up the lengths of the axis. The product of these two probability distributions makes an area. You can see that starting in the top left hand corner with the constant product plot, replacing each axis with a different probability distribution builds up to the joint plot of f(sex,happy)

p0 <- prodplot(happy, ~ 1 | happy, na.rm=TRUE, c("hspine")) +
  aes(fill=happy) +
  scale_fill_manual(values=happypal) +
  scale_y_continuous(name = "1",
                     breaks=0) +
  theme(aspect.ratio = 1, legend.position = "none") +
  scale_x_continuous(name = "happy",
                     breaks = cumsum(rep(1/3, 3)) - rep(1/6, 3),
                     labels = levels(happy$happy))

p1 <- prodplot(happy, ~happy, na.rm=TRUE, c("hspine")) +
  aes(fill=happy) +
  scale_fill_manual(values=happypal) +
  scale_x_continuous(name = "f(happy)",
                     breaks = as.vector(cumsum(happy_marg) - 0.5*happy_marg),
                     labels = levels(happy$happy)) +
  theme(axis.text.y = element_blank(), aspect.ratio = 1, legend.position = "none") +
  scale_y_continuous(name = "1",
                     breaks=0)

p2 <- prodplot(happy, ~ sex | happy, na.rm=TRUE) +
  aes(fill=happy) +
  scale_fill_manual(values=happypal) +
  scale_x_continuous(name = "happy",
                     breaks = cumsum(rep(1/3, 3)) - rep(1/6, 3),
                     labels = levels(happy$happy))+
  scale_y_continuous(name = "f(sex|happy)",
                     breaks = as.vector(cumsum(sex_marg) - 0.5*sex_marg),
                     labels = levels(happy$sex)) +
  theme(aspect.ratio = 1, legend.position = "none")

p3 <- prodplot(happy, ~ sex + happy, na.rm=TRUE) +
  aes(fill=happy) +
  scale_fill_manual(values=happypal) +
  scale_x_continuous(name = "f(happy)",
                     breaks = as.vector(cumsum(happy_marg) - 0.5*happy_marg),
                     labels = levels(happy$happy)) +
  scale_y_continuous(name = "f(sex|happy)",
                     breaks = as.vector(cumsum(sex_marg) - 0.5*sex_marg),
                     labels = levels(happy$sex))+
  theme(aspect.ratio = 1, legend.position = "none")

(p0|p1)/(p2|p3)
```

The plot that expresses $f(x,y)$ in @figfundamentals can be built upon by collapsing the areas of the 6 groups down to lengths (that still sum to 1) and adding in a a new axis to represent a new variable and we can plot $f(x,y,z) = f(x,y)f(z|x,y)$. The problem is that the ability to embed a new variable in the same axis as an old one has nothing to do with the $area = width \times length$ relationship. The actual process that allows the product plots to extend to higher cases is the relationship $\sum_y f(x,y) = f(x)$.
  - $\sum lengths=length$ for the spines case
  - $\sum area = area$ for the fluct and tile case, and
  - $\sum position = position$ for the bar chart case
  
The $area = width \times length$ relationship also cant be applied for the area or position case. Since the area generated by the $area = position \times position$ plot would have overlapping rectangles. The fluct and tile have the problem that there is no relationship between $area \times area = ??$.

## The Non-Trivial Continuous Case
The paper suggests that the framework can be extended to continuous data arbitrarily through binning. This is certainty correct and shown in @fig7 where age, a numeric variables was expressed through the product plot framework. The authors suggest that we could also adopt the theoretical approach of increasing the number of bins infintesimally so our probabulity mass function becomes a probability density function. They also suggest that this approach can work for one continuous variable, but once you have two variables an additional aesthetic is needed and at three variables the product plot framework is broken.

The product plot framework actually seems to break at two continuous variables. The authors propose the question "can the product plot be extended for something like a the kernel density estimate" and the answer is no. The reason is actually quite simple and relates to the fact that the density is not.

If you have a single variable, $x$, and its probability is expressed by the continuous linear function $f(x)=x$. In the discrete binned case, the area under the curse can be expressed by $F(x)=\sum cx$. When we make those bins infintessimally small and calculate the area using an integral we get $F(x)=cx^2$. What is clear is that a summation maintains the order of x while the integral increases the order of x. This means the discrete (or binned) case cannot be embedded on the same axis as the original variable, which is needed for the product plot formula to work beyond two variables. Because the continuous case always needs to be visualised in a dimension higher than the dimension of the original variable, extending the joint display of two variables to the continous case is impossible on a two dimensional plot.


# Appendix
```{r}
#| eval: false
#| echo: false

library(spelling)
qmd <- "ideas/posts/productplots/index.qmd"
ignore <- readLines("WORDLIST")
check_spelling <- spell_check_files(
  qmd,
  ignore = ignore,
  lang = "en_GB"
)
if (nrow(check_spelling) > 0) {
  print(check_spelling)
  stop("Check spelling in Qmd files!")
}
```

```{r}
#| label: fig1
#| echo: false
#| fig-cap: "Figure 1 from the paper"

# Common theme
theme_fig1 <- theme(axis.text = element_blank(),
                    axis.ticks = element_blank(),
                    legend.position = "none",
                    panel.grid = element_blank(),
                    axis.title = element_blank(),
                    aspect.ratio = 1)
# Plots
p1 <- prodplot(happy_clean, ~ happy + marital,
         c("vspine", "hspine"), na.rm = TRUE) +
  aes(fill=marital) +
  scale_fill_brewer() +
  theme_fig1

p2 <- prodplot(happy_clean, ~ marital + happy,
         c("tile", "tile"), na.rm = TRUE) +
  aes(fill=marital) +
  scale_fill_brewer() +
  theme_fig1

p3 <- prodplot(happy_clean, ~ marital + happy,
         c("hspine", "vbar"), na.rm = TRUE) +
  aes(fill=marital) +
  scale_fill_brewer() +
  theme_fig1

p4 <- prodplot(happy_clean, ~ marital + happy,
         c("fluct"), na.rm = TRUE) +
  aes(fill=marital) +
  scale_fill_brewer() +
  theme_fig1 

p5 <- prodplot(happy_clean, ~ marital + happy,
         c("hbar", "vbar"), na.rm = TRUE, levels=1:2) +
  aes(fill=marital) +
  scale_fill_manual(values=c(maritalpal)) +
  theme_fig1

p6 <- prodplot(happy_clean, ~ marital + happy,
         c("hbar", "hspine"), na.rm = TRUE, levels=1:2) +
  aes(fill=marital) +
  scale_fill_manual(values=maritalpal) +
  theme_fig1

p1 + p2 + p3 + p4 + p5 + p6
```

```{r}
#| label: fig3
#| echo: false
#| fig-cap: "Figure 3. Shows fluct size and NA identification. I was unable to get the NA identification plot to look identical to the one in the paper."

# Set theme
themefig3 <- theme(legend.position = "none",
                   aspect.ratio = 5/8,
                   axis.title = element_blank(),
                   plot.title = element_text(hjust = 0.5))

# Plot 1
p1 <- happy_clean %>%
  prodplot(~ age + marital, c("fluct"), na.rm=TRUE) + 
  aes(fill=marital) +
  scale_fill_brewer() +
  scale_x_continuous(name ="Age",
                     breaks=seq(0,875,0.125)[1:8],
                     labels = levels(happy_clean$age))+
  scale_y_continuous(name ="Marital",
                     breaks=seq(0,0.8,0.2),
                     labels = levels(happy_clean$marital)) +
  themefig3 +
  ggtitle("f(age,marital)")

# Plot 2 **incomplete**
# cant get missings to appear
p2 <- prodplot(happy, ~ 1 | health + year, c("vspine", "hspine"), na.rm=TRUE) +
  aes(fill=health) +
  scale_fill_brewer(palette = 5) +
  themefig3 +
  ggtitle("f(1|age,marital)")

p1 | p2
```


```{r}
#| label: fig5
#| echo: false
#| fig-cap: "Figure 5. The graphs are identical but adding the text (with the + and =) warped the plots and I was unable to fix it."
#| warning: false
#| layout-nrow: 2

# Fig 5
# plot 1
# a) copy and paste fig 1 plot 2
p1a <- happy_clean %>%
  prodplot(~ happy, c("hspine"), na.rm=TRUE) + 
  aes(fill=happy) +
  scale_fill_manual(values=happypal) +
  scale_y_continuous(breaks=seq(0,1,1/3)) +
  themefig2
# b 
p1b <- prodplot(happy, ~ sex | happy, c("vspine", "hspine"), na.rm=TRUE) +
  aes(fill=sex) +
  scale_fill_manual(values = sexpal) +
  scale_y_continuous(breaks=seq(0,1,1/3)) +
  themefig2
# c
p1c <- prodplot(happy, ~ sex + happy, c("vspine", "hspine"), na.rm=TRUE) +
  aes(fill=sex) +
  scale_fill_manual(values = sexpal) +
  scale_y_continuous(breaks=seq(0,1,1/3)) +
  themefig2

# plot 2
# a) copy and paste fig 1 plot 1
p2a <- happy_clean %>%
  prodplot(~ happy, c("hbar"), na.rm=TRUE) + 
  aes(fill=happy) +
  scale_fill_manual(values=happypal) +
  scale_y_continuous(breaks=seq(0,1,1/3)) +
  themefig2
# b) copy and paste fig 2 plot 1b
# c
p2c<- prodplot(happy_clean, ~ sex + happy, 
               c("vspine", "hbar"), na.rm=TRUE) +
  aes(fill=sex) +
  scale_fill_manual(values = sexpal) +
  scale_y_continuous(breaks=seq(0,1,1/3)) +
  themefig2

timez <- grid::textGrob("X", just="left")
equals <- grid::textGrob("=")

# Version of Display that warped the plots
# w <- grid::grobWidth(timez)
#gridExtra::grid.arrange(p1a, timez, p1b, equals, p1c,
#             widths = grid::unit.c(10*w, w, 10*w, w, 10*w))

#(p1a | timez | p1b | equals | p1c)/
#(p2a | timez | p1b | equals | p2c)

(p1a | p1b | p1c)/
(p2a | p1b | p2c)
```

```{r}
#| echo: false
#| fig-cap: "Figure 6 from the paper."

# Fig 6
themefig6 <- theme(legend.position = "none",
                   aspect.ratio = 1,
                   axis.text.y = element_blank(),
                   axis.title = element_blank())

# Plot 1
p1 <- prodplot(happy, ~ marital, c("hspine"), na.rm = T) + 
  aes(fill=marital) +
  scale_fill_brewer() +
  themefig6 +
  ggtitle("f(marital)")

# Plot 2
p2 <- prodplot(happy_clean, ~ sex + marital, c("hspine", "hspine"), na.rm=T) + 
  aes(fill=sex) +
  scale_fill_manual(values=sexpal) +
  themefig6 +
  scale_x_continuous(name ="Marital",
                     breaks= as.vector(cumsum(marital_marg) - 0.5*marital_marg),
                     labels = levels(happy_clean$marital)) +
  ggtitle("f(marital, sex)")
# plot 3
p3 <- prodplot(happy_clean, ~ happy + sex + marital, 
         c("vspine", "hspine", "hspine"), na.rm=T) + 
  aes(fill=happy) +
  scale_fill_manual(values = happypal) +
  themefig6 +
  scale_x_continuous(name ="Marital",
                     breaks= as.vector(cumsum(marital_marg) - 0.5*marital_marg),
                     labels = levels(happy_clean$marital)) +
  ggtitle("f(hapy, sex, marital) = \n f(hapy |sex, marital)* \n f(marital, sex)")

p1 + p2 + p3
```

```{r}
#| echo: false
#| fig-cap: "Figure 7 from the paper. While the first plot appears in my summary, the second does not. I included both here for the sake of completeness. Continuous histograms are particularly difficult using the product plots framework since a new function needs to be defined to allow the bars to touch."

# Figure 7
# plot 1
p1 <- prodplot(happy_clean, ~ marital + age, c("vspine", "hspine"),
               na.rm=T) +
  aes(fill=marital) +
  scale_fill_brewer() +
  scale_y_continuous(breaks= seq(0,1,0.25)) +
  theme(legend.position = "none", aspect.ratio = 1,
        axis.text.y = element_blank(),
        axis.title = element_blank())+
  labs(title = "f(marital|age) f(age)")
# plot 2
# quick
p2 <- prodplot(happy_clean, ~ age + marital, c("chbar", "vspine"),
         levels=1:2, na.rm=TRUE) +
  aes(fill=marital) +
  scale_fill_brewer() +
  theme(legend.position = "none",
        aspect.ratio=6/5,
        axis.title = element_blank()) +
  labs(title = "f(age|marital) f(marital)")

p1 + p2
```

```{r}
#| echo: false
#| fig-cap: "Figure 8 from the paper. The fluct diagrams are particularly tedious when trying to adjust the axis, but otherwise these figures were easy enough to replicate."

p1 <- prodplot(happy, ~ happy + finrela + health,
         c("vspine", "fluct"), na.rm = TRUE) + 
  aes(fill=happy) +
  scale_fill_manual(values = happypal) +
  theme(aspect.ratio = 5/4,
        legend.position = "none") +
  # The fluct axis breaks should be evenly spaced
  scale_x_continuous(breaks=seq(0,0.75,0.25),
                     labels = levels(happy$health))+
  scale_y_continuous(breaks=seq(0,0.8,0.2),
                     labels = levels(happy$finrela)) +
  ggtitle("f(hapy, health, finrela) = \n f(hapy |health, finrela)* \n f(health, finrela)")

# Plot 2
p2 <- prodplot(happy, ~ happy | finrela + health,
         c("vspine", "fluct"), na.rm = TRUE)  + 
  aes(fill=happy) +
  scale_fill_manual(values = happypal) +
  theme(aspect.ratio = 5/4,
        legend.position = "none") +
  # these axis are centered for some reason
  scale_x_continuous(breaks=seq(0.125,0.875,0.25),
                     labels = levels(happy$health)) +
  scale_y_continuous(breaks=seq(0.1,0.9,0.2),
                     labels = levels(happy$finrela)) +
  ggtitle("f(hapy|health, finrela))")

# Plot 3
p3 <- prodplot(happy, ~ happy | finrela + health,
         c("hspine", "fluct"), na.rm = TRUE)  + 
  aes(fill=happy) +
  scale_fill_manual(values = happypal) +
  theme(aspect.ratio = 5/4,
        legend.position = "none") +
  # these axis are centered for some reason
  scale_x_continuous(breaks=seq(0.125,0.875,0.25),
                     labels = levels(happy$health))+
  scale_y_continuous(breaks=seq(0.1,0.9,0.2),
                     labels = levels(happy$finrela))+
  ggtitle("f(hapy|finrela, health))")

p1 + p2 + p3
```

```{r}
#| echo: false
#| fig-cap: "Figure 9. Difficulties with this plot were creating a vspine function that removed the gap and identifying how to include weights in the function was difficult."

# Figure 9
p1 <- prodplot(happy_clean, ~ sex + age,
         c("cvspine", "chbar"), na.rm = TRUE) +
  aes(fill=sex) +
  scale_fill_manual(values=sexpal) + 
  scale_y_continuous(breaks=seq(0,1,0.33)) + 
  themefig2 + theme(aspect.ratio = 0.75)
# weighted plot
p2 <- prodplot(happy_clean, wtsall ~ sex + age,
         c("cvspine", "chbar"), na.rm = TRUE) +
  aes(fill=sex) +
  scale_fill_manual(values=sexpal) + 
  scale_y_continuous(breaks=seq(0,1,0.33)) + 
  themefig2 + theme(aspect.ratio = 0.75)

p1 | p2
```

```{r}
#| echo: false
#| fig-cap: "Figure 10. Needed to connect continuous bars with the version of the functions that do not have gaps."

# Figure 10
p1 <- prodplot(happy_clean, ~ happy + age,
         c("vspine", "chbar")) +
  aes(fill=happy) +
  scale_fill_manual(values = happypal) + 
  themefig2 + theme(aspect.ratio = 0.75)

p2 <- prodplot(happy_clean, ~ happy + age,
         c("vspine", "chspine")) +
  aes(fill=happy) +
  scale_fill_manual(values = happypal) +
  themefig2 + theme(aspect.ratio = 0.75)

p1 | p2
```

```{r}
#| echo: false
#| fig-cap: "Figure 11. Working out the cascade function was particularly difficult. The paper seems to adjust the transparency of the levels and have the lower levels filled with white as well, but I was unable to work out how the authors did that."

# Figure 11
p1 <- prodplot(happy_clean, ~ happy + marital + sex , 
         c("vspine", "hspine", "hspine"), na.rm=TRUE,
         cascade=0) + 
  aes(fill=happy) +
  scale_fill_manual(values =happypal) +
  theme_fig1 + theme(aspect.ratio = 0.75)

p2 <- prodplot(happy_clean, ~ happy + marital + sex , 
         c("vspine", "hspine", "hspine"), na.rm=TRUE,
         cascade=0.15, levels=1:3, colour="black", alpha=0.6) + 
  aes(fill= happy) +
  scale_fill_manual(values = rep("white", 3)) +
  theme_fig1 + theme(aspect.ratio = 0.75)

p1 | p2
```

```{r}
#| echo: false
#| fig-cap: "Figure 12. Some of the polar co-ordinate plots behaved strangely and required me to add in extra scalings or swap the order or male and female in the sex variable, but otherwise this plot was simple to replicate."

# Fig 12
themefig12 <- themefig2 + theme(axis.text = element_blank(), axis.ticks = element_blank())
# Plot 1
p1a <- prodplot(happy, ~ sex + happy , 
         c("chbar", "chbar"), na.rm=TRUE, levels=1:2) +
  aes(fill=sex) +
  scale_fill_manual(values = sexpal) +
  themefig12
p1b <- p1a + coord_polar(theta = "x", start = 0, direction = 1, clip = "on")
p1c <- p1a + coord_polar(theta = "y", start = 0, direction = 1, clip = "on")

# Plot 2
p2a <- prodplot(happy, ~ sex + happy , 
         c("cvspine", "chbar"), na.rm=TRUE, levels=1:2) +
  aes(fill=sex) +
  scale_fill_manual(values = sexpal) +
  themefig12
p2b <- p2a + coord_polar(theta = "y", start = 0, direction = 1, clip = "on") 
p2c <- p2a + coord_polar(theta = "x", start = 0, direction = 1, clip = "on") + scale_y_sqrt() + scale_x_sqrt()

# Plot 3
p3a <- prodplot(happy, ~ sex + happy , 
         c("chspine", "chspine"), na.rm=TRUE, levels=1:2) +
  aes(fill=sex) +
  scale_fill_manual(values = sexpal) +
  themefig12
p3b <- p3a + coord_polar(theta = "y", start = 0, direction = 1, clip = "on") + scale_x_sqrt()
p3c <- p3a + coord_polar(theta = "x", start = 0, direction = 1, clip = "on") + scale_x_sqrt()

p4a <- prodplot(happy, ~ sex + happy , 
         c("cvspine", "chspine"), na.rm=TRUE) +
  aes(fill=sex)  +
  scale_fill_manual(values = rev(sexpal)) +
  themefig12
  # Plot b
p4b <- p4a + coord_polar(theta = "y", start = 0, direction = 1, clip = "on") + scale_x_sqrt()
p4c <- p4a + coord_polar(theta = "x", start = 0, direction = 1, clip = "on")+ scale_y_sqrt() + scale_x_sqrt()

(p1a|p2a|p3a|p4a)/(p1b|p2b|p3b|p4b)/(p1c|p2c|p3c|p4c)

```
