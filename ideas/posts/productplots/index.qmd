---
title: "BEX6510 Assignment"
editor_options: 
  chunk_output_type: console
execute:
  echo: false
  warning: false
---

```{r}
#| echo: false
#| include: false

# Load product plots library
# devtools::install_github("hadley/productplots")
library(productplots)
library(tidyverse)
library(patchwork)
library(kableExtra)

happypal <- c("#ff864f","#fcf8ba","#83c84e")
maritalpal <- c("#6BAED6", "#EFF3FF", "#BDD7E7", "#08519C", "#3182BD")
sexpal <- c("#ff7f4e", "#42a8d2")

# Make Version of Data For Histogram Plots
happy_clean <- happy %>% 
  mutate(age = cut(age, breaks = seq(10, 90, 10)),
         happy2 = happy,
         constant = 1)

# Set Up "no gaps" primitive functions
chbar <- function(data, bounds, offset = 0.00, max = NULL){hbar(data, bounds, offset, max)}
cvspine <- function(data, bounds, offset = 0.00, max = NULL){vspine(data, bounds, offset, max)}
chspine <- function(data, bounds, offset = 0.00, max = NULL){hspine(data, bounds, offset, max)}

# Calculation of Marginal marginal for Axis Adjustments
marital_marg = table(happy$marital)/sum(table(happy$marital))

# Common theme
theme_fig1 <- theme(axis.text = element_blank(),
                    axis.ticks = element_blank(),
                    legend.position = "none",
                    panel.grid = element_blank(),
                    axis.title = element_blank(),
                    aspect.ratio = 1)
```

## 1.Paper's Relevance to My Research

The primary focus of my research is uncertainty visualisation. Uncertainty seems to be used interchangeably to express the sampling distribution of an estimate and the population distribution of a parameter. Therefore the current work on uncertainty visualisation seems to jump between expressions of a distribution, statistically significant figures, and variance estimates without any justification. The goal of my research is to combine a the existing work on uncertainty visualisation into a well organised framework and then use that framework to identify and fill gaps in our current graphical techniques.

The *Product Plots* paper connects numerous graphical displays to the statistics that generated each plot. This allows for a systematic and mathematically rigorous approach to understanding the information that exists in a visualisation. Understanding this information is the first step in understanding the connections between existing visualisations and constructing a framework that unites them.

## 2. Product Plot Paper Summary

## 2.1 The Main Idea
The main idea of this paper is deceptively simple. The authors propose a connection between the geometric fact that $Area = Width \times Height$ and the statistical fact that $f(x, y) = f(x|y) \times f(y)$. This is both intuitive and mathematically rigorous considering that the concepts of length, area and probability are all born from measure theory. This idea can be used to simplify visualisations and allows us to break down high dimensional distributions into a combination of lower dimensional distributions for visualisation.

The paper focuses on the discrete case where we are expressing probability mass functions (PMFs) rather than density functions (PDFs). This restriction allows the authors to translate the discrete probabilities of any PMF into disjoint graphical. The paper is not introducing a new way to visualise categorical data, but rather discussing how to break plots down into their statistical elements and understand how this breakdown can impact the final visualisation.

Data from a happiness survey is used in every plot in the paper, and that data is available with the package `productplots`. This is the same data that was used to replicate the figures in this summary and a description of it is provided in @fig-data. The calculated summary of the data provided in the package is identical to that of the paper.

```{r}
#| label: fig-data
#| echo: false
#| fig-cap: "Summary of happy data from productsplot package"

# Get variables
Variable <- colnames(happy)[-1]
df <- data.frame(Variable)

# add descriptions
Description <- c("happiness",
                 "year of survey",
                 "age in years",
                 "sex",
                 "marital status",
                 "highest education",
                 "relative financial status",
                 "heath",
                 "probability weight")
df$Description <- Description

# add Value
getvalues <-function(vector){
  names(vector)
  if (is.numeric(vector))
    return(paste0(min(vector, na.rm=TRUE), "-", max(vector, na.rm=TRUE)))
  if (is.factor(vector)){
    return(levels(vector))
  }
}
Values <- list()
for(i in seq(length(Variable))){
  Values <- append(Values, list(getvalues(happy[,1+i])))
}

df$Values <- Values

df %>%
  kbl() %>%
  kable_classic() %>%
  kable_styling()
```


## 2.2 The R package `productplots`

While the authors leave discussions of the associated R package, `productplots` until the end, I am going to discuss it throughout. My reason for this is two-fold

  1) The structure of the package is helpful in understanding how the product plot breakdown should work, and 
  2) The plots that are made with the package are used throughout the paper and it is easier to understand how the package works when shown along the visualisations it created
  
The main function that the user interacts with to make a product plot and its associated options is `prodplot`. The options that are relevant to understanding the package are `formula`,  `divider`, `cascade`, and `levels`. Each of the options in the function translates to a different element of the product plot framework. In this summary I will start by discussing the graphical primitives of a product plot along with the `divider` argument. Then I will discuss the factorization of $f(x,y)$ along with the `formula` argument and how this factorisation can be broken down into higher dimensions using the  `cascade`, and `levels` arguments. Finally I will highlight the connections between the product plot framework and several existing plots and explain how to adjust the axis on product plots. 

Using the `productplots` package every graphic was reproducible (albeit with some difficulties with the code). The paper suggests that the code can be obtained by emailing the authors, however I had no luck on that front. 

The product plots in the paper also have a considerable amount of code that adjusts the appearance of the plot (e.g axis adjustments). Therefore so most of the code that is used to produce the figures in this summary are aesthetic adjustments rather than changes to the distribution or data displayed. Since every plot is not required for this summary, those that are left out appear at the end of the paper in an appendix for the sake of completeness.

### 2.3 Graphical Primitives
In order to define a product plot the authors need to establish some restrictions. Specifically: 

  1) The area must be proportional to the count
  2) Partitions must be disjoint so that the complete area of each is visible
  3) Partitions must be rectangular so that the the primary perceptual tasks are comparing lengths or positions along a common scale.

The product plot paper suggests that these restrictions give rise to four graphical primitives that make up the product plots. These four graphical primitives are shown in @fig-paper2.

- *Spines*: the width of is proportional to the probability and the height takes up the full range. Spines set each axis to be its own probability function which means each axis must add up to 1 and the total area adds up to 1.
- *Bars*: height (or position along a common scale) is proportional to value and the width is equally divided. The total area of the chart does not equal a probability of 1, the total area of the bars do. 
- *Tiles*: area is proportional to value. The axis of this plot don't have meaning, the plot just tiles the 2d plane with rectangles and tries to keep the aspect ratio of each rectangle close to 1. The total area of the chart equals a probability of 1.
- *Fluct*: area is proportional to the value. A fluct diagram is a collection of squares arranged on a rectangular grid that each have a height and width is proportional to the square root of the probability. The total area of the chart does not equal a probability of 1, the total area of the bars do. 

All 2d primitives (i.e. plots of two varibles $f(x,y)$) are created by combining 1d primitives. The product plots paper suggests that a fluct is a 2d primitive (and needs two data inputs), however it is not clear why this is the case. There does not seem to be anything about the general idea of the fluct (a set of organised areas) that prevents us from using the fluct in same way as a bar chart. While the plot is an area, and therefore 2d, it is only its position that relies on a second axis, and there is no reason it cannot be set to a constant value (as is the case in @fig-paper2). The fluct plot in @fig-paper2 displays the 1d case of that graphical primitive.

Each of these visualisations have their own strengths and weaknesses. Bars allow comparisons along a common scale which is the easiest perceptual task. Spines and tiles are harder to read but work better recursively. Flucts allow comparisons both vertically and horizontally (in the 2d case). There is not a catch all rule that allows us to map these graphical primitives to a set hierarchy.
    
```{r}
#| label: fig-paper2
#| echo: false
#| fig-cap: "Replication of Figure 2 from the product plot paper. Plot depicting the four graphical primitives: bars, spines, tiles and flucts. Bars map f(x) to position, spines map f(x) to length, and tiles and flucts map f(x) to area."

# Common Theme
themefig2 <- theme(legend.position = "none",
                   aspect.ratio = 1,
                   axis.text.y = element_blank(),
                   axis.title = element_blank())
# Plot 1
p1 <- happy_clean %>%
  prodplot(~ happy, c("hbar"), na.rm=TRUE) + 
  aes(fill=happy) +
  scale_fill_manual(values=happypal) +
  scale_y_continuous(breaks=seq(0,1,1/3)) +
  themefig2 +
  ggtitle("Bars")

# Plot 2
p2 <- happy_clean %>%
  prodplot(~ happy, c("hspine"), na.rm=TRUE) + 
  aes(fill=happy) +
  scale_fill_manual(values=happypal) +
  scale_y_continuous(breaks=seq(0,1,1/3)) +
  themefig2 +
  ggtitle("Spines")

# Plot 3
p3 <- happy_clean %>%
  prodplot(~ happy, c("tile"), na.rm=TRUE) + 
  aes(fill=happy) +
  scale_fill_manual(values=happypal) +
  scale_y_continuous(breaks=seq(0,1,1/3)) +
  themefig2 +
  theme(axis.text.x = element_blank()) +
  ggtitle("Tiles")

p4 <- prodplot(happy_clean, ~ happy + constant, c("fluct"), na.rm=T) + 
  aes(fill=happy) +
  scale_fill_manual(values = happypal) +
  theme(aspect.ratio = 1/3,
        legend.position = "none",
        axis.text.y = element_blank()) +
  scale_x_continuous(breaks=seq(0,0.66,0.33),
                     labels = levels(happy$happy)) +
  ggtitle("Fluct")
p1 + p2 + p3 + p4
```

The graphical primitive is selected with the `divider` option in the `productsplot`package. The user can specify each the graphical primitive using its name, and the direction it is applied. For example, a vertical or horizontal spine can be implemented with `vspine()` or `hspine()` respectively. The fluct primitive is considered to be 2d so it does not have a direction associated with it (no vertical or horizontal option). The graphical primitives can be input as a function or a character. For example, the bar chart above was made using the code `prodplot(happy, ~ happy, c("hbar"), na.rm=TRUE)`. Using a function allows users of the package to define their own graphical primitive and build on the package. 

### 2.4 Probability
Every PMF with two or more variables can be factorized into at least two lower level distributions. The product plots paper illustrates this using the joint distribution of $f(sex,happiness)$. The example provided in the product plots paper can be easily replicated using the `happy` data from the `productplots` package and is shown in @fig-paper4. The distribution, $f(sex,happiness)$ contains more information than the marginal and conditional distributions and the joint distribution can be used to find the two lower level distributions.

The proportions in the joint distribution are found by counting the number of people that appear in each possible union of $happy \cap sex$. You can use the joint distribution to find the other distributions by using the probability equations $\sum_{y} f(x,y)= f(x)$ and $\frac{f(x,y)}{f(x)} = f(y|x)$. We connect the concept of probability to the graphical primitives through the factorisation of area as $area=length \times width$. 

```{r}
#| label: fig-paper4
#| echo: false
#| layout-ncol: 2
#| fig-cap: "Calculations of all the distributions that could be of use when plotting sex against happy"
#| fig-subcap: ["f(happy,sex)", "f(sex) and f(happy)", "f(sex|happy)", "f(happy|sex)"]


# Calculate Joint
joint <- table(happy$happy, happy$sex)/sum(table(happy$happy, happy$sex))

# Calculate Marginals
happy_marg <- table(happy$happy)/sum(table(happy$happy))
sex_marg <- table(happy$sex)/sum(table(happy$sex))

# Calculate Conditionals
# Sex conditional on happy
sex_cond_happy <- matrix(nrow=3, ncol=2)
for(i in 1:3){
  sex_cond_happy[i,] <-joint[i,]/happy_marg[i]
}
# Happy conditional on sex
happy_cond_sex <- matrix(nrow=3, ncol=2)
for(i in 1:2){
  happy_cond_sex[,i] <-joint[,i]/sex_marg[i]
}

# Make Nice Joint Distribution
as.data.frame.matrix(joint) %>%
  mutate(across(everything(), round, 2)) %>%
  kbl(caption = "f(happy, sex)") %>%
  kable_classic() %>%
  kable_styling(full_width = F)

# Make Nice Marginal Distributions
options(knitr.kable.NA = '')
tibble(male = c(NA,NA,NA,sex_marg[1]),
       female = c(NA,NA,NA,sex_marg[2]),
       total = c(happy_marg, NA)) %>%
  mutate(rownames = c(levels(happy_clean$happy), " ")) %>%
  column_to_rownames(var="rownames") %>%
  mutate(across(everything(), round, 2)) %>%
  rename(` ` = total) %>%
  kbl(caption = "f(sex) and f(happy)") %>%
  kable_classic() %>%
  kable_styling(full_width = F)

# Make Nice Conditional Distributions
cond_redo <- function(x){
  x %>%
    as.data.frame.matrix(x) %>% 
    rename(male = V1, female = V2) %>%
    mutate(happy = levels(happy_clean$happy)) %>%
    column_to_rownames(var="happy") %>%
    mutate(across(everything(), round, 2))
}
cond_redo(sex_cond_happy) %>%
  kbl(caption = "f(sex|happy)", table.attr = "style='width:30%;'") %>%
  kable_classic() %>%
  kable_styling(full_width = FALSE) 
  
cond_redo(happy_cond_sex)%>%
  kbl(caption = "f(happy|sex)")%>%
  kable_classic() %>%
  kable_styling(full_width = FALSE)
```

Each of these distributions can be used to answer different questions. Joint distributions answer *X and Y* questions (e.g. what proportion of all people are *male and happy*), conditional distributions answer *X given Y* questions (e.g. what proportion of *men people are happy*) and marginal distributions answer *X or Y* questions (e.g. what proportion of *people are male*). Conditional distributions are also useful because they allow us to remove uninteresting relationships.

The paper also suggests that different partitions reveal different features of our data @fig-paper7alt provides an example of a plot that has the same graphical primitives but different factorisations. The paper suggests that that $f(marital,age) = f(marital|age)f(age)$ highlights the fact that most young people are unmarried, while $f(marial,age) = f(age|marital)f(marital)$ highlights that there are few unmarried people over the age of 30. Unfortunately this claim is hard to verify in the paper because the plots presented (the specific figure is in the appendix as @fig-paper7alt) differ in both graphical primitives and factorisation. However, even using @fig-paper7alt, this claim is still difficult to verify because the visual expression of "there are few unmarried people over the age of 30" versus "most young people are unmarried" is hard to identify. The interchangeability of these sentences also does not help.

```{r}
#| echo: false
#| label: fig-paper7
#| fig-cap: Comparison of diferent factorisations of f(age,marital).
#| fig-subcap: ["f(marital|age)f(age)", "f(age|marital)f(marital)"]

# plot 1
p1 <- prodplot(happy_clean, ~ marital + age, c("vspine", "hspine")) +
  aes(fill=marital) +
  scale_fill_brewer() +
  theme(legend.position = "none", aspect.ratio = 1,
        axis.text.y = element_blank())
# plot 2
p2 <- prodplot(happy_clean, ~ age + marital, c("hspine", "vspine")) +
  aes(fill=marital) +
  scale_fill_brewer() +
  theme(legend.position = "none", aspect.ratio = 1,
        axis.text.y = element_blank()) +
  scale_y_continuous(name = "Marital",
                     breaks=seq(0.1,0.9,0.2),
                     labels = levels(happy_clean$marital))
p1 + p2
```

Expressing a distribution in the product plot package is simple, but not explained in the paper, nor in the documentation of the associated package. The `formula` argument should take something in the form of `Weighting ~ Marginal | Conditional`. Where the marginal distribution is always factorised such that `Marginal= x + y` will display a plot factorised as $f(x,y)=f(y)f(x|y)$. For example, the distribution $f(age,marital)=f(marital|age)f(age)$ was produced using the code `prodplot(happy, ~ marital + age, c("vspine", "hspine"))`.

This idea can extend to higher dimensions such as $f(x,y,z)$. Code wise, we would write this as `Marginal = x + y + z` to get the plot $f(x,y,z)=f(y,z)f(x|y,z)$. Then the joint distribution would be automatically further factorised by the package into $f(y,z)= f(z)f(z|y)$. The `level` and `cascade` options help understand how the plot was built up. For example, @fig-cascade, shows the distribution of $f(happy,marital,sex)$ on the left, and the cascaded levels highlight that the plot was made with the factorisation $f(happy,marital,sex)=f(sex)f(marital|sex)f(happy|marital,sex)$. The cascaded plot is made using the code  `prodplot(happy, ~ happy + marital + sex , c("vspine", "hspine", "hspine"), na.rm=TRUE, cascade=0.15, levels=1:3)`.

```{r}
#| echo: false
#| label: fig-cascade
#| fig-cap: "Replication of Figure 11 from the paper. Working out the cascade function was particularly difficult. The paper seems to adjust the transparency of the levels and have the lower levels filled with white as well, but I was unable to work out how the authors did that."

# Figure 11
p1 <- prodplot(happy_clean, ~ happy + marital + sex , 
         c("vspine", "hspine", "hspine"), na.rm=TRUE,
         cascade=0) + 
  aes(fill=happy) +
  scale_fill_manual(values =happypal) +
  theme_fig1 + theme(aspect.ratio = 0.75)

p2 <- prodplot(happy_clean, ~ happy + marital + sex , 
         c("vspine", "hspine", "hspine"), na.rm=TRUE,
         cascade=0.15, levels=1:3, colour="black", alpha=0.6) + 
  aes(fill= happy) +
  scale_fill_manual(values = rep("white", 3)) +
  theme_fig1 + theme(aspect.ratio = 0.75)

p1 | p2
```

### 2.5 Existing Plot Types
It turns out there are a large number of plots that are simply specific cases of the general product plot framework. The vast number of plots that can be constructed using a simple frameworks highlights the importance of developing a strong understanding of the building blocks of plotting and probability before jumping in to developing new plots. 

The connections between the product plot framework and existing plots are shown in @fig-charts. There are many charts that can be considered a product of the product plots framework without loosening any restrictions. There are a few others that are related and can be found by relaxing one or more of the restrictions. Plots that are not certainty connects (i.e. it has not be proven) do not have their product plot equivalent listed. It is interesting how many plots that are typically considered distinct are an extension of a simple framework. @fig-polarplots displays some of the existing plots that are polar-coordinate transformations of a product plot. The data cannot be transformed before being put through the product plots functions so the axis need to be changed with the `coord_polar` function.

```{r}
#| echo: false
#| label: fig-charts

# Normal plots
charts1 <- c("Bar chart/Histogram", "Column chart","Spineplot", "Spinograms", "Fluctuation chart","Stacked bar chart","Nested bar chart", "Equal bin size","Mosaic plot","Double Decker","Treemap","Squarified treemap","Generalised treemaps")
comparisons1 <- c("1 hbar","vbar","1 spine", "1 hbar and 1 hspine","1 fluct","1 hbar and 1 vspine","2 hbars","1 fluct and 1 vspine","alternating hspine vspine","n-1 hspines and 1 vspine","n spines","n tiles","any plot ending with a tile")
t1 <- tibble(Chart = charts1,
             `Product plot` = comparisons1) %>%
  kbl(caption = "Named plots that fit the Product Plot Framework") %>%
  kable_classic() %>%
  kable_styling()

# Relax restraints
charts2 <- c("Pie Chart", "Wind rose and fourfold displays", "Concentric pie chart", "Doughnut plot", "Racetrack plot", "Infoslides", "Fan-lenses", "Stasko's radial displays", "Circular treemaps", "Space-filling curves", "Voronoi treemaps","Nightingales coxcomb", "Cascaded treemaps")
relaxed2 <- c(rep("Rectangular (polar co-ordinates)",11), "Rectangular (polar co-ordinates) & Disjoint partitions", "Disjoint partitions")
comparisons2 <- c("1 hspine", "1 hbar and 1 vspine", "1 hspine", "1hspine and 1 vspine", "1 vbar", "n vbars", rep("", 7))

t2 <- tibble(Chart = charts2,
             `Relaxed constraint`= relaxed2,
             `Product plot` = comparisons2) %>%
  kbl(caption = "Named plots that fit the Product Plot Framework (with some violation to the constraints)") %>%
  kable_classic() %>%
  kable_styling()

t1
t2
```

```{r}
#| echo: false
#| label: fig-polarplots
#| fig-cap: "A replication of Figure 12 from the paper. The second and their row show alternative mappings of x and y to r and Î¸."

# Fig 12
themefig12 <- themefig2 + theme(axis.text = element_blank(), axis.ticks = element_blank())
# Plot 1
p1a <- prodplot(happy, ~ sex + happy , 
         c("chbar", "chbar"), na.rm=TRUE, levels=1:2) +
  aes(fill=sex) +
  scale_fill_manual(values = sexpal) +
  themefig12
p1b <- p1a + coord_polar(theta = "x", start = 0, direction = 1, clip = "on")
p1c <- p1a + coord_polar(theta = "y", start = 0, direction = 1, clip = "on")

# Plot 2
p2a <- prodplot(happy, ~ sex + happy , 
         c("cvspine", "chbar"), na.rm=TRUE, levels=1:2) +
  aes(fill=sex) +
  scale_fill_manual(values = sexpal) +
  themefig12
p2b <- p2a + coord_polar(theta = "y", start = 0, direction = 1, clip = "on") 
p2c <- p2a + coord_polar(theta = "x", start = 0, direction = 1, clip = "on") + scale_y_sqrt() + scale_x_sqrt()

# Plot 3
p3a <- prodplot(happy, ~ sex + happy , 
         c("chspine", "chspine"), na.rm=TRUE, levels=1:2) +
  aes(fill=sex) +
  scale_fill_manual(values = sexpal) +
  themefig12
p3b <- p3a + coord_polar(theta = "y", start = 0, direction = 1, clip = "on") + scale_x_sqrt()
p3c <- p3a + coord_polar(theta = "x", start = 0, direction = 1, clip = "on") + scale_x_sqrt()

p4a <- prodplot(happy, ~ sex + happy , 
         c("cvspine", "chspine"), na.rm=TRUE) +
  aes(fill=sex)  +
  scale_fill_manual(values = rev(sexpal)) +
  themefig12
  # Plot b
p4b <- p4a + coord_polar(theta = "y", start = 0, direction = 1, clip = "on") + scale_x_sqrt()
p4c <- p4a + coord_polar(theta = "x", start = 0, direction = 1, clip = "on")+ scale_y_sqrt() + scale_x_sqrt()

(p1a|p2a|p3a|p4a)/(p1b|p2b|p3b|p4b)/(p1c|p2c|p3c|p4c)

```

## 3. Extensions to the Product Plot Framework
### 3.1 A Better Understanding
My further addition to this paper is a general refinement of this idea that leads to a clear explanation as to why this idea cannot be extended to the continuous case. 

The main idea behind the paper, that we are directly connecting the mathematical statement $f(x,y)=f(x)f(x|y)$ to the geometric statement $area=length \times width$ is false. If we used the $area=length \times width$ fact every time we wanted to add on a variable, the product plot framework would need to add a new axis every time. This fails to keep the plots 2D (which is one of the goals of a product plot). To see how the product plot framework silently drops this connection, let's build a plot up using this assumption.

The fundamental idea of product plots is that a plot of $f(x,y)$ can be expressed by setting one axis to be $f(x)$ and the other to $f(y|x)$. While the two variable case is obvious in how they display the variables, the single variable and higher dimensional cases are less obvious. The single case variables still take up a two dimensional plot. The silent factorisation that occurs in the "one dimensional" cases helps understand how these product plots are actually built up, and gives us two more building blocks for the product plots.
  - $f(x) = f(x)*1$
  - $f(x|y) = f(x|y)\times y$ where $n$ is the number of categories in the variable $y$. 
  - $f(x,y)=f(x)f(y|x)$

Three example plots of these factorisations are shown in @fig-fundamentals and the lengths along the axis can be directly taken from the tables in @fig-paper4. Of course the paper does not make this fundamental breakdown of the single variable distributions explicit, but understanding that every axis is cut into lengths on the basis of some probability mass function (even if it is a constant PMF) makes understanding the process in higher dimensions much easier. @fig-fundamentals also highlights that the way the factorization connects to the plot is not just by "adding plots together" or "adding a new width" but through axis replacement. 

```{r}
#| label: fig-fundamentals
#| echo: false
#| warning: false
#| caption: This figure shows the product plot version of f(happy) and f(sex|happy). The axis have been adjusted to highlight the distribution that breaks up the lengths of the axis. The product of these two probability distributions makes an area. You can see that starting in the top left hand corner with the constant product plot, replacing each axis with a different probability distribution builds up to the joint plot of f(sex,happy)

p0 <- prodplot(happy, ~ 1 | happy, na.rm=TRUE, c("hspine")) +
  aes(fill=happy) +
  scale_fill_manual(values=happypal) +
  scale_y_continuous(name = "1",
                     breaks=0) +
  theme(aspect.ratio = 1, legend.position = "none") +
  scale_x_continuous(name = "happy",
                     breaks = cumsum(rep(1/3, 3)) - rep(1/6, 3),
                     labels = levels(happy$happy))

p1 <- prodplot(happy, ~happy, na.rm=TRUE, c("hspine")) +
  aes(fill=happy) +
  scale_fill_manual(values=happypal) +
  scale_x_continuous(name = "f(happy)",
                     breaks = as.vector(cumsum(happy_marg) - 0.5*happy_marg),
                     labels = levels(happy$happy)) +
  theme(axis.text.y = element_blank(), aspect.ratio = 1, legend.position = "none") +
  scale_y_continuous(name = "1",
                     breaks=0)

p2 <- prodplot(happy, ~ sex | happy, na.rm=TRUE) +
  aes(fill=happy) +
  scale_fill_manual(values=happypal) +
  scale_x_continuous(name = "happy",
                     breaks = cumsum(rep(1/3, 3)) - rep(1/6, 3),
                     labels = levels(happy$happy))+
  scale_y_continuous(name = "f(sex|happy)",
                     breaks = as.vector(cumsum(sex_marg) - 0.5*sex_marg),
                     labels = levels(happy$sex)) +
  theme(aspect.ratio = 1, legend.position = "none")

p3 <- prodplot(happy, ~ sex + happy, na.rm=TRUE) +
  aes(fill=happy) +
  scale_fill_manual(values=happypal) +
  scale_x_continuous(name = "f(happy)",
                     breaks = as.vector(cumsum(happy_marg) - 0.5*happy_marg),
                     labels = levels(happy$happy)) +
  scale_y_continuous(name = "f(sex|happy)",
                     breaks = as.vector(cumsum(sex_marg) - 0.5*sex_marg),
                     labels = levels(happy$sex))+
  theme(aspect.ratio = 1, legend.position = "none")

(p0|p1)/(p2|p3)
```

The plot that expresses $f(x,y)$ in @fig-fundamentals can be built upon by collapsing the areas of the 6 groups down to lengths (that still sum to 1) and adding in a a new axis to represent a new variable and we can plot $f(x,y,z) = f(x,y)f(z|x,y)$. The paper does this implicitly and first plot in @fig-cascade shows the joint distribution of $f(marital,sex)$ constructed this way. The problem with putting the joint distribution $f(marital,sex)= f(sex)f(marital|sex)$ on a single axis, is that we need to expressed $f(sex)$ and $f(marital|sex)$ on the same axis. The ability to embed a new variable in the same axis as an old one has nothing to do with the $area = width \times length$ relationship. The actual process that allows the product plots to extend to higher cases is the relationship $\sum_y f(x,y) = f(x)$. The plot version of this summation translates nicely so that two distributions can be embedded in a single elementary task (i.e. in an area, length or position). They are:
  - $\sum lengths=length$ for the spines case
  - $\sum area = area$ for the fluct and tile case, and
  - $\sum position = position$ for the bar chart case
  
The $area = width \times length$ relationship also cant be applied in the position case (i.e. bar chart) since the area generated by the $area = position \times position$ plot would have overlapping rectangles. This means that you cant combine a vertical bar and a horizontal bar. The fluct and tile have the problem that there is no relationship between $area \times area = ??$ so they can only be combined using the $\sum area = area$ rule and ignore the $area = width \times length$ relation entirely. It actually seems that the only plot that correctly applies the $area = width \times length$ is the 2D case created by a horizontal spine and a vertical spine as it is the only graphical primitive that actually maps to length (and not position or area).

### 3.2 The Non-Trivial Continuous Case
The paper shows that the framework can be extended to continuous data arbitrarily through binning. This is certainty correct and shown in @fig-paper7 where age, a numeric variables was expressed through the product plot framework. The authors suggest that we could also adopt the theoretical approach of increasing the number of bins infinitesimally so our probability mass function becomes a probability density function. They also claim that this approach can work for one continuous variable, but once you have two variables an additional aesthetic is needed and at three variables the product plot framework is broken.

The product plot framework actually seems to break at two continuous variables. The authors propose the question "can the product plot be extended for something like a the kernel density estimate" and the answer is no. The reason is actually quite simple and relates to the fact that the continuous case cannot have multiple distributions embedded on the same axis.

Let us look at an example to see why this is true. Let $x$ be a single random variable with the the probability density function $f(x)=x$ for $0<x<1$. In the discrete binned case, the area under the curse can be expressed by $F(x)= \sum_i^n \frac 1 n xi$. When we make those bins infinitesimally small and calculate the area using an integral we get $F(x)=x^2$. What is clear is that a summation maintains the order of x while the integral increases the order of x. This means the continuous case cannot be embedded on the same axis as the original variable, which is needed for the product plot formula to work beyond two variables. Because the continuous case always needs to be visualised in a dimension higher than the dimension of the original variable, extending the joint display of two variables to the continuos case is impossible on a two dimensional plot. This is why existing 2D depictions of continuous densities (such as a ridge line plot) only ever have one continuous variable.

## 4. Conclusion
While the product plot framework suggests a unique idea that does have a solid foundation in mathematics, it glosses over the way the probability and geometry relate, and when investigated further it does not hold up. This does not mean the product plot framework is not a strong and interesting contribution to information visualisation. The paper presents an idea in how to connect plots to their underlying statistics and also shows how there are a large number of existing and named plots that are simply an expression of this framework. These important ideas show that a solid foundation is necessary for the field of visualisation so that we can prevent researchers repeatedly reinventing the wheel. This also establishes a foundation for my work, a taxonomy that can organise these ideas and establish a solid foundation in uncertainty visualisation.

## 5. Appendix
```{r}
#| eval: false
#| echo: false

library(spelling)
qmd <- "ideas/posts/productplots/index.qmd"
ignore <- readLines("WORDLIST")
check_spelling <- spell_check_files(
  qmd,
  ignore = ignore,
  lang = "en_GB"
)
if (nrow(check_spelling) > 0) {
  print(check_spelling)
  stop("Check spelling in Qmd files!")
}
```

```{r}
#| label: fig-paper1
#| echo: false
#| fig-cap: "Figure 1 from the paper"
#| 
# Plots
p1 <- prodplot(happy_clean, ~ happy + marital,
         c("vspine", "hspine"), na.rm = TRUE) +
  aes(fill=marital) +
  scale_fill_brewer() +
  theme_fig1

p2 <- prodplot(happy_clean, ~ marital + happy,
         c("tile", "tile"), na.rm = TRUE) +
  aes(fill=marital) +
  scale_fill_brewer() +
  theme_fig1

p3 <- prodplot(happy_clean, ~ marital + happy,
         c("hspine", "vbar"), na.rm = TRUE) +
  aes(fill=marital) +
  scale_fill_brewer() +
  theme_fig1

p4 <- prodplot(happy_clean, ~ marital + happy,
         c("fluct"), na.rm = TRUE) +
  aes(fill=marital) +
  scale_fill_brewer() +
  theme_fig1 

p5 <- prodplot(happy_clean, ~ marital + happy,
         c("hbar", "vbar"), na.rm = TRUE, levels=1:2) +
  aes(fill=marital) +
  scale_fill_manual(values=c(maritalpal)) +
  theme_fig1

p6 <- prodplot(happy_clean, ~ marital + happy,
         c("hbar", "hspine"), na.rm = TRUE, levels=1:2) +
  aes(fill=marital) +
  scale_fill_manual(values=maritalpal) +
  theme_fig1

p1 + p2 + p3 + p4 + p5 + p6
```

```{r}
#| label: fig-paper3
#| echo: false
#| fig-cap: "Figure 3. Shows fluct size and NA identification. I was unable to get the NA identification plot to look identical to the one in the paper."

# Set theme
themefig3 <- theme(legend.position = "none",
                   aspect.ratio = 5/8,
                   axis.title = element_blank(),
                   plot.title = element_text(hjust = 0.5))

# Plot 1
p1 <- happy_clean %>%
  prodplot(~ age + marital, c("fluct"), na.rm=TRUE) + 
  aes(fill=marital) +
  scale_fill_brewer() +
  scale_x_continuous(name ="Age",
                     breaks=seq(0,875,0.125)[1:8],
                     labels = levels(happy_clean$age))+
  scale_y_continuous(name ="Marital",
                     breaks=seq(0,0.8,0.2),
                     labels = levels(happy_clean$marital)) +
  themefig3 +
  ggtitle("f(age,marital)")

# Plot 2 **incomplete**
# cant get missings to appear
p2 <- prodplot(happy, ~ 1 | health + year, c("vspine", "hspine"), na.rm=TRUE) +
  aes(fill=health) +
  scale_fill_brewer(palette = 5) +
  themefig3 +
  ggtitle("f(1|age,marital)")

p1 
p2
```

```{r}
#| label: fig-paper5
#| echo: false
#| fig-cap: "Figure 5. The graphs are identical but adding the text (with the + and =) warped the plots and I was unable to fix it."
#| warning: false
#| layout-nrow: 2

# Fig 5
# plot 1
# a) copy and paste fig 1 plot 2
p1a <- happy_clean %>%
  prodplot(~ happy, c("hspine"), na.rm=TRUE) + 
  aes(fill=happy) +
  scale_fill_manual(values=happypal) +
  scale_y_continuous(breaks=seq(0,1,1/3)) +
  themefig2
# b 
p1b <- prodplot(happy, ~ sex | happy, c("vspine", "hspine"), na.rm=TRUE) +
  aes(fill=sex) +
  scale_fill_manual(values = sexpal) +
  scale_y_continuous(breaks=seq(0,1,1/3)) +
  themefig2
# c
p1c <- prodplot(happy, ~ sex + happy, c("vspine", "hspine"), na.rm=TRUE) +
  aes(fill=sex) +
  scale_fill_manual(values = sexpal) +
  scale_y_continuous(breaks=seq(0,1,1/3)) +
  themefig2

# plot 2
# a) copy and paste fig 1 plot 1
p2a <- happy_clean %>%
  prodplot(~ happy, c("hbar"), na.rm=TRUE) + 
  aes(fill=happy) +
  scale_fill_manual(values=happypal) +
  scale_y_continuous(breaks=seq(0,1,1/3)) +
  themefig2
# b) copy and paste fig 2 plot 1b
# c
p2c<- prodplot(happy_clean, ~ sex + happy, 
               c("vspine", "hbar"), na.rm=TRUE) +
  aes(fill=sex) +
  scale_fill_manual(values = sexpal) +
  scale_y_continuous(breaks=seq(0,1,1/3)) +
  themefig2

timez <- grid::textGrob("X", just="left")
equals <- grid::textGrob("=")

# Version of Display that warped the plots
# w <- grid::grobWidth(timez)
#gridExtra::grid.arrange(p1a, timez, p1b, equals, p1c,
#             widths = grid::unit.c(10*w, w, 10*w, w, 10*w))

#(p1a | timez | p1b | equals | p1c)/
#(p2a | timez | p1b | equals | p2c)

(p1a | p1b | p1c)/
(p2a | p1b | p2c)
```

```{r}
#| echo: false
#| fig-cap: "Figure 6 from the paper."

# Fig 6
themefig6 <- theme(legend.position = "none",
                   aspect.ratio = 1,
                   axis.text.y = element_blank(),
                   axis.title = element_blank())

# Plot 1
p1 <- prodplot(happy, ~ marital, c("hspine"), na.rm = T) + 
  aes(fill=marital) +
  scale_fill_brewer() +
  themefig6 +
  ggtitle("f(marital)")

# Plot 2
p2 <- prodplot(happy_clean, ~ sex + marital, c("hspine", "hspine"), na.rm=T) + 
  aes(fill=sex) +
  scale_fill_manual(values=sexpal) +
  themefig6 +
  scale_x_continuous(name ="Marital",
                     breaks= as.vector(cumsum(marital_marg) - 0.5*marital_marg),
                     labels = levels(happy_clean$marital)) +
  ggtitle("f(marital, sex)")
# plot 3
p3 <- prodplot(happy_clean, ~ happy + sex + marital, 
         c("vspine", "hspine", "hspine"), na.rm=T) + 
  aes(fill=happy) +
  scale_fill_manual(values = happypal) +
  themefig6 +
  scale_x_continuous(name ="Marital",
                     breaks= as.vector(cumsum(marital_marg) - 0.5*marital_marg),
                     labels = levels(happy_clean$marital)) +
  ggtitle("f(happy, sex, marital) = \n f(happy |sex, marital)* \n f(marital, sex)")

p1 + p2 + p3
```

```{r}
#| echo: false
#| label: fig-paper7alt
#| fig-cap: "Figure 7 from the paper. While the first plot appears in my summary, the second does not. I included both here for the sake of completeness. Continuous histograms are particularly difficult using the product plots framework since a new function needs to be defined to allow the bars to touch."

# Figure 7
# plot 1
p1 <- prodplot(happy_clean, ~ marital + age, c("vspine", "hspine"),
               na.rm=T) +
  aes(fill=marital) +
  scale_fill_brewer() +
  scale_y_continuous(breaks= seq(0,1,0.25)) +
  theme(legend.position = "none", aspect.ratio = 1,
        axis.text.y = element_blank(),
        axis.title = element_blank())+
  labs(title = "f(marital|age) f(age)")
# plot 2
# quick
p2 <- prodplot(happy_clean, ~ age + marital, c("chbar", "vspine"),
         levels=1:2, na.rm=TRUE) +
  aes(fill=marital) +
  scale_fill_brewer() +
  theme(legend.position = "none",
        aspect.ratio=6/5,
        axis.title = element_blank()) +
  labs(title = "f(age|marital) f(marital)")

p1 + p2
```

```{r}
#| echo: false
#| fig-cap: "Figure 8 from the paper. The fluct diagrams are particularly tedious when trying to adjust the axis, but otherwise these figures were easy enough to replicate."

p1 <- prodplot(happy, ~ happy + finrela + health,
         c("vspine", "fluct"), na.rm = TRUE) + 
  aes(fill=happy) +
  scale_fill_manual(values = happypal) +
  theme(aspect.ratio = 5/4,
        legend.position = "none") +
  # The fluct axis breaks should be evenly spaced
  scale_x_continuous(breaks=seq(0,0.75,0.25),
                     labels = levels(happy$health))+
  scale_y_continuous(breaks=seq(0,0.8,0.2),
                     labels = levels(happy$finrela)) +
  ggtitle("f(happy, health, finrela) = \n f(happy |health, finrela)* \n f(health, finrela)")

# Plot 2
p2 <- prodplot(happy, ~ happy | finrela + health,
         c("vspine", "fluct"), na.rm = TRUE)  + 
  aes(fill=happy) +
  scale_fill_manual(values = happypal) +
  theme(aspect.ratio = 5/4,
        legend.position = "none") +
  # these axis are centered for some reason
  scale_x_continuous(breaks=seq(0.125,0.875,0.25),
                     labels = levels(happy$health)) +
  scale_y_continuous(breaks=seq(0.1,0.9,0.2),
                     labels = levels(happy$finrela)) +
  ggtitle("f(happy|health, finrela))")

# Plot 3
p3 <- prodplot(happy, ~ happy | finrela + health,
         c("hspine", "fluct"), na.rm = TRUE)  + 
  aes(fill=happy) +
  scale_fill_manual(values = happypal) +
  theme(aspect.ratio = 5/4,
        legend.position = "none") +
  # these axis are centered for some reason
  scale_x_continuous(breaks=seq(0.125,0.875,0.25),
                     labels = levels(happy$health))+
  scale_y_continuous(breaks=seq(0.1,0.9,0.2),
                     labels = levels(happy$finrela))+
  ggtitle("f(happy|finrela, health))")

p1 
p2 
p3
```

```{r}
#| echo: false
#| fig-cap: "Figure 9. Difficulties with this plot were creating a vspine function that removed the gap and identifying how to include weights in the function was difficult."

# Figure 9
p1 <- prodplot(happy_clean, ~ sex + age,
         c("cvspine", "chbar"), na.rm = TRUE) +
  aes(fill=sex) +
  scale_fill_manual(values=sexpal) + 
  scale_y_continuous(breaks=seq(0,1,0.33)) + 
  themefig2 + theme(aspect.ratio = 0.75)
# weighted plot
p2 <- prodplot(happy_clean, wtsall ~ sex + age,
         c("cvspine", "chbar"), na.rm = TRUE) +
  aes(fill=sex) +
  scale_fill_manual(values=sexpal) + 
  scale_y_continuous(breaks=seq(0,1,0.33)) + 
  themefig2 + theme(aspect.ratio = 0.75)

p1 | p2
```

```{r}
#| echo: false
#| fig-cap: "Figure 10. Needed to connect continuous bars with the version of the functions that do not have gaps."

# Figure 10
p1 <- prodplot(happy_clean, ~ happy + age,
         c("vspine", "chbar")) +
  aes(fill=happy) +
  scale_fill_manual(values = happypal) + 
  themefig2 + theme(aspect.ratio = 0.75)

p2 <- prodplot(happy_clean, ~ happy + age,
         c("vspine", "chspine")) +
  aes(fill=happy) +
  scale_fill_manual(values = happypal) +
  themefig2 + theme(aspect.ratio = 0.75)

p1 | p2
```


