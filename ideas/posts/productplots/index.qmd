---
title: "BEX6510 Assignment"
editor_options: 
  chunk_output_type: console
---

```{r}
#| label: setup
#| echo: false

# Load product plots library
devtools::install_github("hadley/productplots")
library(productplots)
library(tidyverse)
library(patchwork)
library(gt)

colpal <- c("#ff864f","#fcf8ba","#83c84e")
bluepal <- c("#6BAED6", "#EFF3FF", "#BDD7E7", "#08519C", "#3182BD")
#bluepal <- c("#EFF3FF", "#BDD7E7", "#6BAED6", "#3182BD", "#08519C")
twopal <- c("#ff7f4e", "#42a8d2")

# Make Version of Data For Histogram Plots
happy_clean <- happy %>% 
  mutate(age = cut(age,
                   breaks = seq(10, 90, 10)))

# Set Up "no gaps" primitive functions

```
## Explain how this paper relates to my research


# Summary of Product Plots Paper
```{r}
#| label: fig1
#| echo: false
#| fig-cap: "The selection of six plots that make up Figure 1 of the Products Plot paper"

# Common theme
theme_fig1 <- theme(axis.text = element_blank(),
                    axis.ticks = element_blank(),
                    legend.position = "none",
                    panel.grid = element_blank(),
                    axis.title = element_blank(),
                    aspect.ratio = 1)
# Plots
p1 <- prodplot(happy_clean, ~ happy + marital,
         c("vspine", "hspine"), na.rm = TRUE) +
  aes(fill=marital) +
  scale_fill_brewer() +
  theme_fig1

p2 <- prodplot(happy_clean, ~ marital + happy,
         c("tile", "tile"), na.rm = TRUE) +
  aes(fill=marital) +
  scale_fill_brewer() +
  theme_fig1

p3 <- prodplot(happy_clean, ~ marital + happy,
         c("hspine", "vbar"), na.rm = TRUE) +
  aes(fill=marital) +
  scale_fill_brewer() +
  theme_fig1

p4 <- prodplot(happy_clean, ~ marital + happy,
         c("fluct"), na.rm = TRUE) +
  aes(fill=marital) +
  scale_fill_brewer() +
  theme_fig1 

p5 <- prodplot(happy_clean, ~ marital + happy,
         c("hbar", "vbar"), na.rm = TRUE, levels=1:2) +
  aes(fill=marital) +
  scale_fill_manual(values=c(bluepal)) +
  theme_fig1

p6 <- prodplot(happy_clean, ~ marital + happy,
         c("hbar", "hspine"), na.rm = TRUE, levels=1:2) +
  aes(fill=marital) +
  scale_fill_manual(values=bluepal) +
  theme_fig1

p1 + p2 + p3 + p4 + p5 + p6
```


## 1 Introduction
- Visualising tables of counts, proportions, and probabilities
- Framework for visualisations of categorical data
- Focuses on  area of charts - area of graphical element is proportional to the underlying count, proportion or probability
- product plots 
  - main idea: width x height = area 
  - and conditional x marginal = joint
  - also have inverse where high dimensional distribution can be factorised into a product of low-dimensional conditional and marginal distributions.
- To illustrate the idea they use the same data from a happiness survey in all examples. 
  - Discrete: age, year
  - Categorical: degree, relative financial status, happiness, health, marital status, sex
  - Continuous: wstall (probability weight)?

## 2 Related Work
- Other efforts to develop domain specific languages for visualisation are:
  - APT [6] and VisQL [7]
    - *Add notes from these papers*
    - . This work is similar but carves out a smaller niche.
    - Compared to these product plots are less expressive but more efficient because the number of primitives (simple elemements) required to describe the smaller domain is smaller (?)
  - HiVE [8]
    - *Add notes from this paper*
  - Polaris [9]
    - *Add notes from this paper*
    - essentially a 3D extension of the trellis framework [10,11]

## 3 Graphical Primitives
- area must be proportional to count.
  - key constraint for area plots
  - total area is usually constrained
- partitions must be disjoint.
  - to be able to see the complete area each rectangle must be not overlapping. 
- partitions must be rectangular
  - allows many interesting pecterptual tasks to only require comparing lengths or positions along a common scale 
  - these are easier than comparing areas
  - little evidence rectangles are the best shape for comparison [15,16]
- These constraints give rise to 4 graphical primitives

### 3.1 1d primitives

```{r}
#| label: fig2
#| echo: false
#| fig-cap: "Figure 2 replaication: Graph of three 1d primitives"

# Common Theme
themefig2 <- theme(legend.position = "none",
                   aspect.ratio = 1,
                   axis.text.y = element_blank()) 
# Plot 1
p1 <- happy_clean %>%
  prodplot(~ happy, c("hbar"), na.rm=TRUE) + 
  aes(fill=happy) +
  scale_fill_manual(values=colpal) +
  themefig2

# Plot 2
p2 <- happy_clean %>%
  prodplot(~ happy, c("hspine"), na.rm=TRUE) + 
  aes(fill=happy) +
  scale_fill_manual(values=colpal) +
  themefig2

# Plot 3
p3 <- happy_clean %>%
  prodplot(~ happy, c("tile"), na.rm=TRUE) + 
  aes(fill=happy) +
  scale_fill_manual(values=colpal) +
  themefig2 +
  theme(axis.text.x = element_blank())

p1 + p2 + p3
```

- There are three 1d primitives
  - bars: height s proportional to value and width is equally divided. Occupy mean(x-max(x)) of the total area *(???)* isnt that the negative of the whitespace?? shouldnt it be mean(X/max(X))
  - splines: width proportional to value, height occupies full range.
  - tiles: No restrictions on height and width, just tile the plane with rectangles and try to keep the aspect ratio of each rectangle close to 1. A squarified treemap.
- Each visualisation has strengths and weaknesses
  - easy to compare the value associated with bars because comparing position on a common scale
  - splines and tiles are harder to read but work better reccursively

### 3.2 2d primitives
- all 2d primitives are created by combining 1d primitives except for one
  - fluct: has height and width proportional to the square root of the count and is arranged on a rectangular grid formed by the levels of the two variables. 
  - allows comparisons both vertically and horizontally
  - special case occurs when two variables are jointly uniformly distributed, usually as a result of conditioning. useful for identifying missing combinations

```{r}
#| label: fig2
#| echo: false
#| fig-cap: "Recreation of Figure 3 that shows fluct size and NA identification"

# Set theme
themefig3 <- theme(legend.position = "none",
                   aspect.ratio = 5/8,
                   axis.title = element_blank(),
                   plot.title = element_text(hjust = 0.5))

# Plot 1
p1 <- happy_clean %>%
  prodplot(~ age + marital, c("fluct"), na.rm=TRUE) + 
  aes(fill=marital) +
  scale_fill_brewer() +
  scale_x_continuous(name ="Age",
                     breaks=seq(0,875,0.125)[1:8],
                     labels = levels(happy_clean$age))+
  scale_y_continuous(name ="Marital",
                     breaks=seq(0,0.8,0.2),
                     labels = levels(happy_clean$marital)) +
  themefig3 +
  ggtitle("f(age,marital)")

# Plot 2 **incomplete**
# cant get missings to appear
p2 <- prodplot(happy, ~ 1 | health + year, c("vspine", "hspine"), na.rm=TRUE) +
  aes(fill=health) +
  scale_fill_brewer(palette = 5) +
  themefig3 +
  ggtitle("f(1|age,marital)")

p1/p2
```

## 4 Probabulity and Plot Products
- To construct plots of higher dimensions we need a way to decompose them into 1d and 2d components.

### 4.1 Joint distribution are the product of marginals and conditionals

```{r}
#| label: fig4
#| echo: false
#| fig-cap: replication of Figure 4, the 5 distributions of importance

# Calculate Joint
joint <- table(happy$happy, happy$sex)/sum(table(happy$happy, happy$sex))

# Calculate Marginals
happy_marg <- table(happy$happy)/sum(table(happy$happy))
sex_marg <- table(happy$sex)/sum(table(happy$sex))

# Calculate Conditionals
# Sex conditional on happy
sex_cond_happy <- matrix(nrow=3, ncol=2)
for(i in 1:3){
  sex_cond_happy[i,] <-joint[i,]/happy_marg[i]
}
# Happy conditional on sex
happy_cond_sex <- matrix(nrow=3, ncol=2)
for(i in 1:2){
  happy_cond_sex[,i] <-joint[,i]/sex_marg[i]
}

# Make Nice Joint Distribution
t1 <- as.data.frame.matrix(joint) %>% 
  gt(rownames_to_stub = TRUE) %>%
  tab_header(title = "f(happy, sex)")%>%
  fmt_number(decimals = 2)

# Make Nice Conditional Distributions
t2 <- as.data.frame.matrix(sex_cond_happy) %>% 
  rename(male = V1, female = V2) %>%
  mutate(happy = levels(happy_clean$happy)) %>%
  gt(rowname_col = "happy") %>%
  tab_header(title = "f(sex|happy)") %>%
  fmt_number(decimals = 2)
t3 <- as.data.frame.matrix(happy_cond_sex) %>% 
  rename(male = V1, female = V2) %>%
  mutate(happy = levels(happy_clean$happy)) %>%
  gt(rowname_col = "happy") %>%
  tab_header(title = "f(happy|sex)") %>%
  fmt_number(decimals = 2)

# Make Nice Marginal Distributions


t4 <- as.data.frame(happy_marg) %>% 
  rename(happy=Var1) %>%
  gt(rowname_col = "happy") %>%
  tab_options(column_labels.hidden = TRUE) %>%
  tab_header(title = "f(happy)")%>%
  fmt_number(decimals = 2)

t5 <- as.data.frame(sex_marg) %>% 
  rename(happy=Var1) %>%
  gt(rowname_col = "happy") %>%
  tab_options(column_labels.hidden = TRUE) %>%
  tab_header(title = "f(sex)")%>%
  fmt_number(decimals = 2)

t1/(t2 + t3)/(t4 + t5)
```

- turn data into a PMF
- Variables are happy and sex are shown in several tables. 
- Joint distribution
  - Q: what proportion of all people are male and very happy?
- Conditional distributions
  - Q: what proportion of males are not too happy?
- Marginal Distributions
  - Q: What proportion of respondents were male? What proportion were very happy?
- Have the equation $f(x|y) = f(x,y)/f(y)$
  - Therefore given a conditional and a marginal we can find the joint distribution
  - $f(x,y) = f(x|y)f(y)$
  - Only the joint distribution contains the full information about the relationship between all variables involved
  - can get the marginal distribution by integrating/summing the other variable out, i.e. $f(x)=\int_y{f(x,y)}$
  - These definitions extend to higher dimensions
    - $f(x,y,z) = f(x,y|z)f(z)$
    - $f(x,y,z) = f(x|z,y)f(z,y)$
    - $f(x,y,z) = f(x|y,z)f(y|z)f(z)$
- Therefore we can build any high dimensional PMF as a product of low-dimensional conditional and marginal PMFs
- Use low-dimensional primitives as graphical analog of this multiplication

### 4.2 Area is the product of height and width
- area is also a product so it can be connected
  - e.g. 1 mosaic plot: height f(sex|happy) X width = f(happy) = area f(sex, happy)
  - e.g. 2: stacked bar chart: position f(happy) X proportion f(sex|happy) = length f(sex, happy) ~ area = c*f(happy, sex).
- Algorithm gives a rough idea of computation
  - calculate one marginal and i conditional distributions
  - for each probability in the marginal distribution, 
    - divide the probabilities (aka the bounds) into i sets of new bounds, one for each level of the categorical variabe. 
    - if i=1 like in the example we keep the original bounds
    - for each new bound there is a matching conditional distribution, call the partition function
    - drop one element from the list of drawing primitives
- Different partitions reveal different features
  - Hard to identify if this is because they used splines for both of the first plot but splines and bar for the second plot or because of the different distributions.
  - $f(marial,age) = f(marital|age)f(age)$ highlights most young people are unmaried
  - $f(marial,age) = f(age|marital)f(marital)$ highlights few unmarried people over the age of 30
  - I am also not sure how much I agree with this assessment of what the plots say. I don't disagree with the premise though. I do wonder if that is because both comments are about being unmarried.
- Conditioning is also a useful tool because it allows us to remove relationships that are known or uninteresting.
  - Give example of $f(happy, health, financial)$
  - When show all as raw proportions $f(happy, health, financial)$ = $f(happy| health, financial)f(heath,financial)$ your main take away is that most people are in good health and average financial standing, however it is difficult to see how happiness varies within these conditions
  - If you condition on health and financial status, comparing happiness across these groups becomes easier because comparing positions along a common scale is an easier perception task.
  - Depending on the comparison we are most interested in, we can make it easier to compare across different variables

## 5 Existing Plot Types
1D
  - Bar chart (hbar)
  - Column chart (vbar)
  - Spineplot (spine)
  - Fluctuation chart (fluct)
2D
  - Stacked bar chart (1hbar and 1vspine)
  - Nested bar chart (2 hbars)
  - Equal bin size (1 fluct and 1 vspine)
  - Mosaic plot (alternating hspine vspine)
  - Double Decker (n-1 hspines and 1 vspine)
  - Treemap (n spines)
  - Squarified treemap (n tiles)
  - Generalised treemaps (any plot ending with a tile)
  - Trellis graphics (similar but not identical, created by conditioning in tellising variables)

## 6 Display Considerations
- Hard to label axis
  - often two variables end up on the same axis so we cant label it.
  - there are other ways to label the axis other than colour
    - e.g. text labels used to occupy the space of the region they label
    - in the interactive setting can have linked brushing from high dimensional to low dimensional plots
    - some apsect ratios are more aesthetically pleasing, e.g. the square for the fluct. wonder if aspect ratios close to the golden ratio might be more appealing
    - does not seem to be previous work on aspect ratios and aesthetics although they do seem to affect perception
    - need more research on aesthetics and usability

## Variations and Extensions
### 7.1 Weighting
- instead of counts can plot weighted data
- i.e. redo plots where the data is weighted because of sampling or some other reason
- weights are also useful to move from number of countries to number of people
### 7.2 Continuous Data
- instead of counts can plot continuous data
- trivially extended by binning the continuous data to make them discrete
  - can do bins of equal width OR bins containing an equal number of points
- extension allows product plots to also describe histograms and spinograms
  - no gaps are displated between adjacent rectangles when displaying continuous data
- more theoretical approach is to increase number of bins infintesimally leading to a probability density function
  - approach can include one continuous variable but two variables need an additional aesthetic such as colour to visualise a 2d joint density.
  - >=3 continuous variables breaks the product plots framework
  - if you express the innersmost proportion with colour (instead of area) can describe dimensional stacking (apparently a SPLOM is dimensional stacking)
  
### 7.3 Area not proportional to weight
- relax display constraints
- to distinguish between zeros, missing values, and very small values
- zero weight should have zero area but instead set it to be at a minimum perceptable size.
  - set as a different colour to let the reader know the area=weight rule is violated
- could also  be useful to restrict max value so you can see other small values
- could also do other non linear transformations
  - e.g. Tukey applied the technique to histograms where the y axis has a square root scale

### 7.4 Non-disjoint partitions
- relax display constraints
- e.g. cascaded treemaps 
- makes it easier to see all the levels of the hierarchy and highlights the structure
  - e.g. each of $f(sex)$, $f(marital, sex)$, and $f(happy|sex, marital)$ get a layer.
  - hard to tell when something is $f(X|Y)$ or $f(X,Y)$

### 7.5 Non-rectangular partitions
- relax display constraints
- pie chart not retangular and does not fall into the framework, but it does relate
  - it is a hspline draw in polar coodinates with the x-coordinate mapped to angle and the y coordinate mapped to radius
- Other plots that are product plots drawn in polar coodinates
  - Wind rose and fourfold displays (1 hbar and 1 vspine)
    - Nightingales coxcomb is similar but the slices overlap so it violates the disjoint area constraint
  - Concentric pie chart (1 hspine)
  - Doughnut plot (1hspine and 1 vspine)
  - Racetrack plot (1 vbar)
  - Infoslides (n vbars)
- research suggests that visualisations in polar coordinates are harder to read that visualisations in cartesian coordinates
- y-axis must be square root transformed to ensure that counds stay proportional to areas
  - Fan-lenses and Stasko's radial displays deliberatrely do not do this to emphasise the outer levels.
- Other non-rectangular graphics
  - circular treemaps
  - space-filling curves
  - voronoi treemaps

## 8 R Package
- made an R package called productplots
- two main functions
  - prodcalc: computes the coordinates of each rectangle
  - prodplot: displays the rectangles with the ggplot2 package
- each graphical primitive is represented by a function (e.g. hspine()) which allows you to write a new function and use the existing calculation and display algorithms

## 9 Conclusion
- Framework is successful at describing many existing graphics that display tables of counts, proportions and probabilities
- framework leads to many possibilities as a 4d PMF can be factorised in 5 different ways, with 24 different ways of ordering the variables. Have 5 yeas of displaying a 1d PMF and 1 way of displaying a 2D pmf
  -  defines a large space of potential plots. Have $24*(5^4+5^2+5^2+5^2+1)=16824$ plots before we consider conditioning
  - IDK where that number came from
    - on the function end:
      - 24 combinations of variables
      - 5 ways of factorising
      - 24*5 different factorisations
      - 5 ways of displaying a 1D PMF
        - within the factorisations there are (4, 2, 2, 2, 0) 1D PMFs
      - 1 way of displaying a 2D pmf
        - within the factorisations there are (0, 1, 1, 1, 2)
        - it looks like it is done
          $5*5*5*5$
          $5*5*1$
          $5*1*5$
          $1*5*5$
          $1*1$
- Well thought out interactions make it easier to navigate this space & developed a prototype as part of the cranvas suite of interactive grahics
- also exploring the connection between product plots and log-linear (AKA poisson) models (the statistical models most commonly used for count data)
  - e.g. looking for straight lines in a mosaic plot corresponds to a formal test of independence between variables
  - generally we are interested in connections between visualisation and formal statistical tests
  - also how significant coefficients can help us choose a set of useful plots
  - given a question can we select appropriate plots? given a plot can we suggest questions it might answer?
- Product plots need to be extension to display uncertainty
- Continuous data is incorperated in a simplistic manner.
  - can it be extended for something like the average shifted histogram or the kernel density estimate

# Personal notes
- The distinction between conditional and joint seems to be very blurry and coding the distributions makes this even more confusing
  - also makes the number of permutations a little odd because it doesn't quite seem to work how they suggest
- Cant make weighted data plots in their thing

# Unsorted Code
```{r}

# Fig 5
# plot 1
# a) copy and paste fig 1 plot 2
# b 
prodplot(happy_clean, ~ sex | happy, c("vspine", "hspine")) +
  aes(fill=sex) +
  scale_fill_brewer(palette = 5,
                    type = "qual") +
  theme(legend.position = "none",
        aspect.ratio = 1,
        axis.text.y = element_blank()) 
# c
prodplot(happy_clean, ~ sex + happy, c("vspine", "hspine")) +
  aes(fill=sex) +
  scale_fill_brewer(palette = 5,
                    type = "qual") +
  theme(legend.position = "none",
        aspect.ratio = 1,
        axis.text.y = element_blank()) 
# plot 2
# a) copy and paste fig 1 plot 1
# b) copy and paste fig 2 plot 1b
# c
prodplot(happy_clean, ~ sex + happy, c("vspine", "hbar")) +
  aes(fill=sex) +
  scale_fill_brewer(palette = 5, type = "qual") +
  theme(legend.position = "none",
        aspect.ratio = 1,
        axis.text.y = element_blank()) 

# Fig 6
# plot 1
prodplot(happy_clean, ~ marital, c("hspine")) + 
  aes(fill=marital) +
  scale_fill_brewer() +
  theme(legend.position = "none",
        aspect.ratio = 1,
        axis.text.y = element_blank())
# plot 2
  # calculate breaks
x = table(happy$marital)/sum(table(happy$marital))
y = cumsum(x)
marital_breaks2 = as.vector(y - 0.5*x)
  # plot
prodplot(happy_clean, ~ sex + marital, c("hspine", "hspine")) + 
  aes(fill=sex) +
  scale_fill_brewer(palette = 5, type = "qual") +
  theme(legend.position = "none",
        aspect.ratio = 1,
        axis.text.y = element_blank()) +
  scale_x_continuous(name ="Marital",
                     breaks= marital_breaks2,
                     labels = marital_breaks)
# plot 3
prodplot(happy_clean, ~ happy + sex + marital, 
         c("vspine", "hspine", "hspine")) + 
  aes(fill=happy) +
  scale_fill_brewer(palette = 5, type = "qual") +
  theme(legend.position = "none",
        aspect.ratio = 1,
        axis.text.y = element_blank())+
  scale_x_continuous(name ="Marital",
                     breaks= marital_breaks2,
                     labels = marital_breaks)

# Figure 7
# plot 1
prodplot(happy_clean, ~ marital + age, c("vspine", "hspine")) +
  aes(fill=marital) +
  scale_fill_brewer() +
  theme(legend.position = "none", aspect.ratio = 1,
        axis.text.y = element_blank())
# plot 2
# quick
prodplot(happy_clean, ~ age + marital, c("chbar", "vspine"),
         levels=1:2, na.rm=TRUE) +
  aes(fill=marital) +
  scale_fill_brewer() +
  theme(legend.position = "none")

# long in next chunk
# should have been
prodplot(happy_clean, ~ age + marital, c("hspine", "vspine")) +
  aes(fill=age) +
  scale_fill_brewer() +
  theme(legend.position = "none", aspect.ratio = 1,
        axis.text.y = element_blank()) +
  scale_y_continuous(name = "Marital",
                     breaks=seq(0.1,0.9,0.2),
                     labels = levels(happy_clean$marital))

# Figure 8
# Plot 1
prodplot(happy, ~ happy + finrela + health,
         c("vspine", "fluct"), na.rm = TRUE) + 
  aes(fill=happy) +
  scale_fill_manual(values = colpal) +
  theme(aspect.ratio = 5/4,
        legend.position = "none") +
  # The fluct axis breaks should be evenly spaced
  scale_x_continuous(breaks=seq(0,0.75,0.25),
                     labels = levels(happy$health))+
  scale_y_continuous(breaks=seq(0,0.8,0.2),
                     labels = levels(happy$finrela))

# Plot 2
prodplot(happy, ~ happy | finrela + health,
         c("vspine", "fluct"), na.rm = TRUE)  + 
  aes(fill=happy) +
  scale_fill_manual(values = colpal) +
  theme(aspect.ratio = 5/4,
        legend.position = "none") +
  # these axis are centered for some reason
  scale_x_continuous(breaks=seq(0.125,0.875,0.25),
                     labels = levels(happy$health))+
  scale_y_continuous(breaks=seq(0.1,0.9,0.2),
                     labels = levels(happy$finrela))

# Plot 3
prodplot(happy, ~ happy | finrela + health,
         c("hspine", "fluct"), na.rm = TRUE)  + 
  aes(fill=happy) +
  scale_fill_manual(values = colpal) +
  theme(aspect.ratio = 5/4,
        legend.position = "none") +
  # these axis are centered for some reason
  scale_x_continuous(breaks=seq(0.125,0.875,0.25),
                     labels = levels(happy$health))+
  scale_y_continuous(breaks=seq(0.1,0.9,0.2),
                     labels = levels(happy$finrela))

# Figure 9
prodplot(happy_clean, ~ sex + age,
         c("vspine", "hbar"), na.rm = TRUE) +
  aes(fill=sex)
# weighted plot
prodplot(happy_clean, wtsall ~ sex + age,
         c("vspine", "hbar"), na.rm = TRUE) +
  aes(fill=sex)

# Figure 10
prodplot(happy_clean, ~ happy + age,
         c("vspine", "hbar")) +
  aes(fill=happy) +
  scale_fill_manual(values = colpal)
prodplot(happy_clean, ~ happy + age,
         c("vspine", "hspine")) +
  aes(fill=happy) +
  scale_fill_manual(values = colpal)

# Figure 11
prodplot(happy_clean, ~ happy + marital + sex , 
         c("vspine", "hspine", "hspine"), na.rm=TRUE,
         cascade=0) + 
  aes(fill=happy) +
  scale_fill_manual(values =colpal) +
  theme(legend.position = "none",
        aspect.ratio = 1)

prodplot(happy_clean, ~ happy + marital + sex , 
         c("vspine", "hspine", "hspine"), na.rm=TRUE,
         cascade=0.15, levels=1:3, colour="black", alpha=0.6) + 
  aes(fill=happy) +
  scale_fill_manual(values = colpal) +
  theme_minimal() +
  theme(legend.position = "none",
        aspect.ratio = 0.75) 

# Fig 12 (a lot of these are not quite right)
prodplot(happy, ~ sex + happy , 
         c("hbar", "hbar"), na.rm=TRUE, levels=1:2) +
  aes(fill=sex) +
  # Plot b
  #coord_polar(theta = "x", start = 0, direction = 1, clip = "on") +
  # Plot c
  #coord_polar(theta = "y", start = 0, direction = 1, clip = "on") +
  scale_fill_manual(values = twopal) 


prodplot(happy, ~ sex + happy , 
         c("vspine", "hbar"), na.rm=TRUE, levels=1:2) +
  aes(fill=sex) +
  # Plot b
  #coord_polar(theta = "x", start = 0, direction = 1, clip = "on") +
  # Plot c
  #coord_polar(theta = "y", start = 0, direction = 1, clip = "on") +
  scale_fill_manual(values = twopal)

prodplot(happy, ~ sex + happy , 
         c("hspine", "hspine"), na.rm=TRUE, levels=1:2) +
  aes(fill=sex) +
  # Plot b
  #coord_polar(theta = "x", start = 0, direction = 1, clip = "on") +
  # Plot c
  coord_polar(theta = "y", start = 0, direction = 1, clip = "on") +
  scale_fill_manual(values = twopal) 

prodplot(happy, ~ sex + happy , 
         c("hspine", "hspine"), na.rm=TRUE) +
  aes(fill=sex) +
  # Plot b
  coord_polar(theta = "x") +
  # Plot c
  coord_polar(theta = "y") +
  scale_fill_manual(values = twopal) 

prodplot(happy, ~ sex + happy , 
         c("vspine", "hspine"), na.rm=TRUE) +
  aes(fill=sex) +
  # Plot b
  coord_polar(theta = "x", start = 0, direction = 1) +
  # Plot c
  coord_polar(theta = "y", start = 0, direction = 1) +
  scale_fill_manual(values = twopal) 
```

```{r}
#| eval: false
# Fig 7 Attempt
library(dplyr)
marital_mins <- tibble(marital = levels(happy$marital),
                       ymin = c(0,as.vector(y)[1:4]))
age_mins <- tibble(age = levels(happy_clean$age),
                   xmin = seq(0,0.875,0.125),
                   xmax = seq(0.125,1,0.125))

# make joint...
joint <- table(happy_clean$age, happy_clean$marital)/sum(table(happy_clean$happy, happy_clean$sex))
# ... and marginal distribution
marital_mar <- table(happy$marital)/sum(table(happy$marital))
# find value to scale histograms by
max_joint <- apply(joint,2,max)
scale <- min(marital_mar/max_joint)

# find positions for age polygon
positions <- as.data.frame.matrix(joint) %>%
  rownames_to_column("age") %>%
  pivot_longer(cols=-age, names_to = "marital")  %>%
  left_join(marital_mins) %>%
  left_join(age_mins) %>%
  mutate(ymax = ymin + value*scale) %>%
  rownames_to_column("id") %>%
  select(-value) %>%
  pivot_longer(cols=c(xmin,xmax), names_to = "xid", values_to = "x") %>%
  pivot_longer(cols=c(ymin,ymax), names_to = "yid", values_to = "y")

# need to swap rows 3 and 4 of each polygon
fouth <- seq(from=4, to=length(positions$x), by=4)
third <- even - 1
xholder <- positions$x
yholder <- positions$y
positions$x[third] <- xholder[fouth]
positions$x[fouth] <- xholder[third]
positions$y[third] <- yholder[fouth]
positions$y[fouth] <- yholder[third]

# marital positions
big_positions <- tibble(marital = rep(levels(happy$marital), each=4),
                        y = rep(c(0,rep(as.vector(y)[-5], each=2), 1), each=2),
                        x = rep(c(0,1,1,0),5))

# Finally make plot
ggplot() +
  geom_polygon(data = big_positions, aes(x = x, y = y, fill = marital, group = marital), colour="black") +
  geom_polygon(data = positions, aes(x = x, y = y, fill = marital, group = id), colour="black")  +
  scale_fill_brewer() +
  scale_x_continuous(name = "Age",
                     breaks= seq(0,0.875,0.125)+0.125*0.5,
                     labels = levels(happy_clean$age))+
  scale_y_continuous(name = "Marital",
                     breaks= marital_breaks2,
                     labels = levels(happy_clean$marital)) +
  theme(legend.position = "none",
        aspect.ratio = 1.25)


```

```{r}

#Try with homemade no gap horizontal bar
chbar <- function(data, bounds, offset = 0.00, max = NULL){hbar(data, bounds, offset, max)}

prodplot(happy_clean, ~ happy + marital,
         c("chbar", "S"), na.rm = TRUE) +
  aes(fill=marital) +
  scale_fill_brewer()

```


## R Code Issue List
- If I use scale_fill_brewer() instead of scale_fill_manual() I get a clear background instead of the grey background.
- Axis need to be rescaled and labeled with scale_x_continuous. The ticks are evenly spaced out so they are easy to recalculate and label. Default has weird axis.
- need to set aspect ratio to #categoriesY/#categoriesX to keep flux plot as squares.
- Couldnt really get NA values to appear in Figure 3. I don't know how the paper got those gaps.

# Extension of Work
- Does this work extend to expected values or visualisations of other mathematical process?
- Could be expanded by looking at which other perceptual tasks are combinations of others
- extension to continuous case
- Can the questions be combined similarly the way we can combine the PMF and the graphics
- Connections between formal statistical tests and visualisations
- uncertainty visualisation extensions